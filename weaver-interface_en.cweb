\input tex/epsf.tex
\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents the implementation of the user
interface used by the Weaver Game Engine. The code provided is
intended for creating buttons, text, menus, and other user interface
elements. It primarily manages shaders and creates elements that can
be moved, rotated, clicked, and made to respond to mouse
hovering. Support for adding sound effects is also included. The API
is designed to be flexible, allowing users to extend it and customize
its behavior by registering new functions.}

\secao{1. Introduction}

A graphical user interface is how a program communicates with and
receives input from the user. In a typical program, we might have
menus, buttons, pop-up windows, and other common graphical
elements. In games, the user interface is usually conceptually
simpler, consisting of a few menus and visual elements that provide
information about the game state---for example, a life counter in the
corner of the screen.

The truth is that in a computer game, we can assume almost nothing
about the appearance of the user interface. A strategy game might
include many menus that appear when the player clicks on a unit, while
a platform game might only display information about equipped items
and a life counter. The appearance and behavior of such elements can
vary greatly depending on the game genre.

The only universal characteristic we assume for our interface elements
is that they appear on top of the game scene and are not obscured by
objects from the game world. Typically, we render the interface after
rendering the game world, and elements from the game world cannot
interact with the interface. Interfaces are not part of the simulated
world---they are merely elements that convey information to the player
that would otherwise be difficult to represent.

Our objective here will be creating an API where the user can create a
new interface using the function:


@<Function Declaration (interface.h)@>=
struct user_interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float z, float width,
                                  float height);
@


The first argument is a file that will be opened and interpreted to
obtain information about the interface texture (for example, it could
be an image filename). The second argument is a file containing the
OpenGL shader. Both arguments can be NULL. A NULL shader means a
default shader will be used. A NULL texture file means the interface
will have no texture. The remaining arguments specify the initial
position and size of the interface.

We can define shaders more easily by providing an additional library
of GLSL functions. This can be done by passing a string containing
function definitions in GLSL to the following function:

@<Function Declaration (interface.h)@>+=
void _Wset_interface_shader_library(char *source);
@

We can move interfaces using the function:

@<Function Declaration (interface.h)@>+=
void _Wmove_interface(struct user_interface *i, float x, float y, float z);
@

We assume that the position of an interface is given by the
coordinates of its center. The $x$ and $y$ axes represent the
horizontal and vertical position, respectively. The $z$ axis
determines which interface appears in front when multiple interfaces
occupy the same space.

We can also rotate it with the function:

@<Function Declaration (interface.h)@>+=
void _Wrotate_interface(struct user_interface *i, float rotation);
@

The function above takes as an argument the amount, in radians, by
which the interface will be rotated relative to its default
orientation.

We can also resize the interface with the function below:

@<Function Declaration (interface.h)@>+=
void _Wresize_interface(struct user_interface *i,
                        float new_width, float new_height);
@

The function below renders in the screen or drawing area all the
previously created interfaces:

@<Function Declaration (interface.h)@>+=
void _Wrender_interface(unsigned long long time);
@

The time parameter in the function above is used when the interface
needs to know how many microseconds have passed since the last
function call. This is useful for correctly rendering interfaces with
animated textures.

However, rendering all previously created interfaces may not always be
what the user wants. Sometimes, a developer may want to render only
the interfaces created after a certain point in time. For this
purpose, the function below creates a marker in the interface
history. From that point on, when we request to render all interfaces,
only those created after the marker will be rendered.

@<Function Declaration (interface.h)@>+=
void _Wmark_history_interface(void);
@

But what if we want to render some of the interfaces created before
the last history marker? In this case, we can create a new interface
that is, in fact, just a reference to a previously created one.

@<Function Declaration (interface.h)@>+=
struct user_interface *_Wlink_interface(struct user_interface *i);
@

To interact with all interfaces created up to the last marker, we use
the function below. It executes the programmed actions, if any, for
each interface when the user hovers over it, moves the mouse away, or
clicks on it.

@<Function Declaration (interface.h)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool left_click,
                          bool middle_click, bool right_click);
@

But how can we erase and destroy interfaces that are no longer needed?
For this purpose, we use the following function, which deletes all
interfaces created after the last history marker. This function also
removes the last marker, restoring the state to what it was just
before the marker was created. Interfaces created before that marker
will be rendered again.

@<Function Declaration (interface.h)@>+=
void _Wrestore_history_interface(void);
@

All of this requires managing our interface history, shaders, and
markers, which in turn involves memory allocation and
deallocation. There are two types of allocations we use: for permanent
data that will remain in memory for a long time, and for temporary
data that will be deallocated shortly afterward. We will provide
functions to handle allocation and deallocation in both cases.

@<Local Variables (interface.c)@>=
#include <stdlib.h>
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@

By default, we use the allocation and deallocation functions from the
standard library. However, users can provide custom functions to
replace them. In addition to these four functions, we also support
custom functions that are called immediately before and after loading
a new interface. These functions are initially set to NULL, but users
can later assign them to other functions:

@<Local Variables (interface.c)@>=
static void (*before_loading_interface)(void) = NULL;
static void (*after_loading_interface)(void) = NULL;
@

All custom functions are chosen during the API initialization:

@<Function Declaration (interface.h)@>+=
#include <stdlib.h> // Define  'size_t' type
void _Winit_interface(int *window_width, int *window_height,
                      void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void (*before_loading_interface)(void),
                      void (*after_loading_interface)(void),
                      ...);
@

It is possible to initialize the deallocation functions with
\monoespaco{NULL}. This means that allocated memory will not be
deallocated. This can be useful in scenarios where the memory manager
uses its own garbage collector and does not want interference.

The function above accepts a variable number of arguments. First, it
receives pointers to variables where the window width and height will
be stored. These values will be stored at the provided locations:

@<Local Variables (interface.c)@>=
static int *window_width = NULL, *window_height = NULL;
@

The window size arguments are followed by the custom functions
described earlier. After the six initial functions comes a
NULL-terminated list of arguments, each consisting of a string
followed by a function that creates a new interface given a file. The
string represents a filename extension (for example, ``gif'', ``jpg'',
or others). The function corresponding to the file extension has the
following type:

@<Local Macros (interface.c)@>=
typedef void pointer_to_interface_function(void *(*)(size_t), void (*)(void *),
                                          void *(*)(size_t), void (*)(void *),
                                          void (*)(void), void (*)(void),
                                          char *, void *);
@

The function receives as arguments the allocation and deallocation
functions, a filename, and a void pointer to the interface that should
be populated with information from the file. Each of these functions
is expected to correctly interpret files with the previously specified
extensions and fill the given interface with textures extracted from
the file. In this way, we delegate to the user the responsibility of
providing functions capable of creating interfaces from different file
formats. The last argument is a void pointer because these functions
could be used both for visual user interfaces and for sound
interfaces. Each type of interface uses different structs.

Since we have an initialization function, we also need a finalization
function:

@<Function Declaration (interface.h)@>+=
void _Wfinish_interface(void);
@

Up to this point, we have presented functions and their behavior for
visual interfaces. However, you can also create audio interfaces using
the function below:

@<Function Declaration (interface.h)@>+=
struct sound *_Wnew_sound(char *filename);
@

To play the sound loaded by the previous function, we use the function
below:

@<Function Declaration (interface.h)@>+=
bool _Wplay_sound(struct sound *snd);
@

To choose which audio device we want to use for playback, it may be
useful to gather more information about the available audio devices
and which one is currently in use. The function below provides this
information by returning the number of available devices, the name of
each device as a list of strings, and the index of the current default
device in that list:

@<Function Declaration (interface.h)@>+=
char **_Wget_sound_device_information(int *number_of_devices,
                                      int *current_device);
@

The function below changes the current audio device to the one at
position $n$ in the list of device names returned by the function
above, where $n$ is the argument passed to the function. It retursn
true if the operation was successful and false otherwise.

@<Declaração de Função (interface.h)@>+=
bool _Wselect_sound_device(int chosen_device);
@

This concludes the description of our API functions.

The API behavior can also be modified by defining the macro
\monoespaco{W\_FORCE\_LANDSCAPE}. In an environment where the width is
greater than the height, setting this macro has no effect. However, if
the window height is greater than the width and this macro is defined,
the $x$ and $y$ axes will be rotated 90 degrees
counter-clockwise. This feature is useful for creating more consistent
user interfaces on mobile devices. In such cases, we can always assume
that there is more horizontal than vertical space, and, if necessary,
the user can rotate their device.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{interface.h}.

We show below the structure of the file \monoespaco{interface.h}:


@(src/interface.h@>=
#ifndef __WEAVER_INTERFACE
#define __WEAVER_INTERFACE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif  
@<Include General Headers (interface.h)@>
@<General Macros (interface.h)@>
@<Data Structures (interface.h)@>
@<Function Declaration (interface.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

The code above shows the default boilerplate for defining a header in
our C API. The first two lines and the last one are macros that ensure
the header is not included more than once in a single compilation
unit. Lines 3, 4, 5, and the three lines before the last one make the
header compatible with C++ code. These lines tell the compiler that we
are using C code and, therefore, it can apply optimizations assuming
that no C++-specific features---such as operator overloading---will be
used.

Next, we include a header that allows us to use boolean variables. You
may also notice some parts highlighted in red. One of them is labeled
``Function Declaration (interface.h)'', the same title used for most of
the code declared earlier. This means that all previously defined code
blocks with that title will be inserted at this point in the file. The
other red-highlighted parts represent code that we will define in the
following sections.

If you want to understand how the \monoespaco{interface.c} file
relates to this header, its structure is as follows:

@(src/interface.c@>=
#include "interface.h"
@<Local Headers (interface.c)@>
@<Local Macros (interface.c)@>
@<Local Data Structures (interface.c)@>
@<Local Variables (interface.c)@>
@<Auxiliary Local Functions (interface.c)@>
@<API Functions Definition (interface.c)@>
@

All the code presented in this document will be placed in one of these
two files. No other files will be created.

\subsecao{1.2. Supporting Multiple Threads}

Most of the code defined in this document is portable. The only
requirement we assume is that an OpenGL context has already been
created and is active. However, there is one non-portable component
that must be defined differently depending on the system and
environment: mutex support.

A mutex is a data structure that controls access by multiple processes
to a shared resource. Its implementation varies depending on the
operating system and environment. Due to its non-portability, we
introduce it here separately from the rest of the code.

On Linux and BSD, a mutex is defined using the \monoespaco{pthread}
library and follows its naming conventions. On Windows, a mutex is
called a critical section. In WebAssembly, we do not define mutexes
for now, as multithreading is currently not supported in this
environment.

@<General Macros (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#define _MUTEX_DECLARATION(mutex) pthread_mutex_t mutex
#define _STATIC_MUTEX_DECLARATION(mutex) static pthread_mutex_t mutex
#elif defined(_WIN32)
#define _MUTEX_DECLARATION(mutex) CRITICAL_SECTION mutex
#define _STATIC_MUTEX_DECLARATION(mutex) static CRITICAL_SECTION mutex
#elif defined(__EMSCRIPTEN__)
#define _MUTEX_DECLARATION(mutex)
#define _STATIC_MUTEX_DECLARATION(mutex)
#endif
@

This means that on Linux and BSD, we need to include the headers for
the \monoespaco{pthread} library. On Windows, we simply include the
default Windows header:

@<Include General Headers (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#include <pthread.h>
#elif defined(_WIN32)
#include <windows.h>
#endif
@

Each declared mutex must be initialized. For this, we use the
following macros:

@<Local Macros (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_INIT(mutex) pthread_mutex_init(mutex, NULL);
#elif defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@

To finalize and delete a mutex, we use the following macros:

@<Local Macros (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(mutex);
#elif defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@

Once we have a mutex, there are two operations we can perform. The
first is to request ownership of the mutex. If another process is
already using it, we must wait until the mutex becomes available:

@<Local Macros (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(mutex);
#elif defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@

And finally, when we are done using the resource protected by the
mutex, we signal that other processes can now use it:

@<Local Macros (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(mutex);
#elif defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@

\secao{2. Data Structures}

In this section, we describe the four main data structures managed by
the API: shaders, user interfaces, links to previously created
interfaces, and history markers.

\subsecao{2.1. Shader Data Structure}

To render any object using the video card, we need to specify a set of
rendering rules. At what position should the object be drawn? What is
its color? What texture should be applied? Should the rendering change
based on time or the viewing angle? To answer these questions, we use
special programs that run on the GPU, called shaders.

In addition to the shader program itself, we also need to store
associated variables. Shader programs access a list of variables
during execution, and we can update their values before each run. For
every modifiable variable, we must store its address within the shader
program. Only with this information can we change the variable’s value
at runtime.

A shader data structure has the following layout:

@<Local Data Structures (interface.c)@>=
struct shader {
  int type;
  void *next; // Linked list pointer
  GLuint program; // The shader program
  /* These are the shader variables that users could modify: */
  GLint uniform_foreground_color, uniform_background_color; // Bg/Fg color
  GLint uniform_model_view_matrix; // Model-view matrix
  GLint uniform_interface_size; // Object size in pixels
  GLint uniform_mouse_coordinate; // Mouse coordinate (interface referential)
  GLint uniform_time; // Time counter
  GLint uniform_integer; // Arbitrary integer
  GLint uniform_texture1; // Object texture
};
@

Since we are using OpenGL data types such as \monoespaco{GLuint}, we
need to include the appropriate OpenGL headers:

@<Include General Headers (interface.h)@>+=
#if defined(__linux__) || defined(BSD) || defined(__EMSCRIPTEN__)
#include <EGL/egl.h>
#include <GLES3/gl3.h>
#endif
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
@

The first two variables in the data structure exist because each
shader will be stored in a linked list that may also contain other
types of data structures. The type field indicates which kind of
structure is stored in the list, and the pointer to the next element
forms the linked list by linking each element to the following one.

In a shader data structure, the type field is always set to
\monoespaco{TYPE\_SHADER}. The possible values, covering all types of
supported data structures, are:

@<Local Macros (interface.c)@>=
#define TYPE_INTERFACE 1 // A visual interface that could be rendered
#define TYPE_LINK      2 // Link to a previous interface
#define TYPE_MARKING   3 // Marker in the interface history
#define TYPE_SHADER    4 // Shader to render interfaces
#define TYPE_SOUND     5 // A sound effect for interfaces
@

The program variable in the shader data structure stores the compiled
shader. All the variables that follow it indicate the locations of
configurable variables within the shader program. Not all of these
variables will necessarily be present in every shader, but they
represent the set of variables supported by our API. They include
variables for vertex data, size, position, color, textures, and other
related attributes.

\subsecao{2.2. User Interface Data Structure}

The most complex data structure in this document is the one that
stores information about visual user interfaces. Its full definition
is as follows:

@<Data Structures (interface.h)@>=
struct user_interface{
  int type;
  void *next; // Pointer for linked list
  float x, y, _x, _y, z;
  float rotation, _rotation;
  float mouse_x, mouse_y;
  float height, width;
  float background_color[4], foreground_color[4];
  int integer;
  bool visible;
  GLfloat _transform_matrix[16];
  struct shader *shader_program;
  _MUTEX_DECLARATION(mutex);
  /* Interacting functions */
  bool _mouse_over;
  void (*on_mouse_over)(struct user_interface *);
  void (*on_mouse_out)(struct user_interface *);
  void (*on_mouse_left_down)(struct user_interface *);
  void (*on_mouse_left_up)(struct user_interface *);
  void (*on_mouse_middle_down)(struct user_interface *);
  void (*on_mouse_middle_up)(struct user_interface *);
  void (*on_mouse_right_down)(struct user_interface *);
  void (*on_mouse_right_up)(struct user_interface *);
  /* Attributes below should be filled by the loading function: */
  GLuint *_texture1;
  bool _loaded_texture;
  bool animate;
  unsigned number_of_frames;
  unsigned current_frame;
  unsigned *frame_duration;
  unsigned long _t;
  int max_repetition;
  /* Additional data for vector textures or procedural animation */
  void *_internal_data;
  void (*_free_internal_data)(void *);
  void (*_reload_texture)(struct user_interface *);
};
@

Now we will describe the purpose of each part of this structure. The
type and next pointer were already described and are the same as those
presented in the shader data structure.

After the type and next fields, we store the position in pixels (for
axes $x$ and $y$) and the z-index (axis $z$) of the interface. Then we store
the rotation (in radians) and the width and height (in pixels). These
values can be read but should not be changed directly. To modify them,
you must use the designated functions defined in later sections. This
is necessary because properly updating position, rotation, and size
requires modifying the transformation matrix, which is how OpenGL and
our shaders internally represent this information. The z-index must
also be updated in a separate list that stores the correct rendering
order for each element.

Note that we actually have two sets of variables to store position
($x$, $y$) and rotation. This is because when the
\monoespaco{W\_FORCE\_LANDSCAPE} macro is defined, and the window
height is greater than its width, the x and y axes are rotated, and
the interface is rotated 90 degrees as well. In this case, the
variables \monoespaco{\_x}, \monoespaco{\_y}, and
\monoespaco{\_rotation} store the logical (unrotated) values, while
\monoespaco{x}, \monoespaco{y}, and \monoespaco{rotation} store the
rotated ones. When the window is wider than it is tall or the macro is
not defined, both sets of variables will store the same values.

The \monoespaco{mouse\_x} and \monoespaco{mouse\_y} attributes store
the mouse coordinates relative to the bottom-left corner of the
interface, rather than the screen. If the interface is rotated, the
coordinate system is rotated accordingly.

The foreground and background colors are in RGBA format, with each
component ranging from 0 to 1. These values are passed to the shader,
although the shader may or may not use them. Similarly, the integer
attribute is passed to the shader, and it is up to the shader to
decide whether to make use of it.

The visible attribute determines whether the interface should be
rendered. If set to false, it will not appear on the screen.

Next, we have a pointer to the shader data structure associated with
this interface, which defines the rendering behavior.

The interaction function pointers are usually initialized to
\monoespaco{NULL}. If not, they are called when the mouse enters or
leaves the interface, or when a mouse button is pressed or released
over it. Additionally, we have a boolean flag that indicates whether
the mouse is currently over this interface.

The attributes following the interaction functions are initialized to
0, false, or NULL. However, the loading function (responsible for
interpreting the interface’s source file) may change and update these
values. This loading function is passed to the API’s initialization
function and interprets files with specific extensions to generate
textures and other interface-related information.

Next, we have a pointer to the OpenGL texture used by the
interface. It is possible to have more than one texture---for example,
if the source file contains multiple images or is an animated GIF. In
such cases, each animation frame is stored as a separate
texture. After successfully loading a texture, the
\monoespaco{texture\_loaded} flag should be set to true.

If multiple textures are loaded, the animate flag determines whether
the interface should animate. This value can be changed to pause or
resume the animation.

The following two attributes store the total number of frames in the
animation and the index of the current frame. Frame indices start at
0.

The \monoespaco{frame\_durations} pointer should point to an array
with the duration of each frame. If the number of frames is 0 or 1,
this pointer can be NULL.

The \monoespaco{\_t} variable keeps track of the elapsed time. It
should be set to zero after the interface has been fully loaded and
its texture is ready. It is then incremented periodically to determine
when to switch to the next animation frame.

The \monoespaco{max\_repetition} attribute defines how many times an
animated interface should repeat. If the value is zero, the animation
loops indefinitely. If it is a positive number, the animation will
stop after reaching the specified repetition count and will remain on
the last frame.

The \monoespaco{\_internal\_data},
\monoespaco{\_free\_internal\_data}, and
\monoespaco{\_reload\_texture} fields are optionally initialized by
the loading function. \monoespaco{\_internal\_data} is a pointer to
any arbitrary data structure. \monoespaco{\_free\_internal\_data} is a
function used to deallocate this structure when the interface is
destroyed. \monoespaco{\_reload\_texture} is a pointer to a function
called whenever the interface changes size, or on every animation
frame if the interface is animated but contains a single texture. This
makes it possible to use vector-based textures that are recalculated
on resize, as well as procedural animations in which each frame is
generated dynamically rather than preloaded.

\subsecao{2.3. Markers in History}

As mentioned in the Introduction, the logic that determines which
interfaces are accessible at any given moment relies on markers placed
in the interface history. All interfaces created after the most recent
marker are accessible, while those created before it are not: they
will not be rendered, and the user will not be able to interact with
them. Multiple markers can be created, and the most recent existing
marker can be deleted, which also removes the interfaces created after
it.

To make this possible, each marker must store a pointer to the
previous marker and to the previous structure in the linked list. This
allows us to replace a deleted marker with the one it references. Each
marker also stores the number of interfaces created after it---this
corresponds to the number of interfaces that will remain active while
the marker exists and is the most recent one.

@<Local Data Structures (interface.c)@>=
struct marking {
  int type;
  void *next; // Ponter to linked list
  void *prev; // Pointer to previous element in the linked list
  struct marking *previous_marking;
  unsigned number_of_interfaces;
};
@

Note that this is declared as a local data structure in the
\monoespaco{interface.c} file. We did this because the structure is
intended for internal use only within our API. Users do not need to
manipulate markers directly. Instead, they interact with this data
structure indirectly through the functions
\monoespaco{\_Wmark\_history\_interface} and
\monoespaco{\_Wrestore\_history\_interface}, as described in the
Introduction.

\subsecao{2.4. Link to Other Interfaces}

If an interface is inaccessible because it was created before the last
history marker, it is possible to create a link to it using the
\monoespaco{\_Wlink\_interface} function. Linking to the older
interface makes it act as if it were a newly created one, thereby
making it accessible again. Creating a link means creating and storing
the following struct in the linked list:

@<Local Data Structures (interface.c)@>+=
struct link{
  int type;
  void *next; // Pointer to linked list
  struct user_interface *linked_interface;
};
@

Besides the information required for the linked list, such as the type
and the pointer to the next element, the only additional data we need
to store in a link is a pointer to the previously linked interface.

\subsecao{2.5. Sound Interfaces}

Sound interfaces are noises that should be produced when the user
interacts with something—typically with other visual interfaces, or
with the keyboard and mouse. They are structures that reference a
buffer containing all the audio they must play. Because of this, a
sound interface should be a short sound, not something long like a
piece of music.

@<Data Structures (interface.h)@>+=
struct sound {
  int type;
  void *next; // Pointer to linked list
  bool _loaded_sound; // The sound was already loaded?
  ALuint buffer; // References an audio buffer
};
@

In addition to the initial variables that all other interfaces have,
the data structure above contains a reference to a buffer of type
\monoespaco{ALuint}. This is the type used by the low-level audio
library we will use, OpenAL. Its API aims to be similar to OpenGL, and
this is the type it uses for unsigned integers. We should also include
the headers for this library as follows:

@<Include General Headers (interface.h)@>+=
#include <AL/al.h>
#include <AL/alc.h>
@

\secao{3. Initializing and Finalizing the API}

The purpose of initialization in this API is to define all the custom
functions that will be used for memory allocation, deallocation, and
interface creation management. Finalization deallocates the data used
to store information about some of these functions. It also resets all
custom functions to their default values.

\subsecao{3.1. Initialization}

Here, our goal is to set the six custom functions discussed in the
Introduction, as well as to receive a variable-length list of
functions that will be used to interpret the contents of files with
specific extensions.

To store the functions from this variable-length list, we use the
following structure:

@<Local Data Structures (interface.c)@>=
struct file_function {
  char *extension;
  void (*load_texture)(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void (*before_loading_interface)(void),
                      void (*after_loading_interface)(void),
                      char *source_filename, void *target);
};
static unsigned number_of_file_functions_in_the_list = 0;
static struct file_function *list_of_file_functions = NULL;
@

The struct is essentially a pair consisting of a function that
extracts textures from a given file (and receives all the custom
functions to be used), and a string representing a file
extension. After defining this structure, we create a pointer to a
list of such structures, which initially represents an empty list.

Later, once this list is no longer empty---that is, after
initialization---we will be able to iterate over its elements and
retrieve the appropriate loading function using the following
auxiliary function:

@<Auxiliary Local Functions (interface.c)@>=
static inline void (*get_loading_function(char *ext))
                          (void *(*permanent_alloc)(size_t),
                           void (*permanent_free)(void *),
                           void *(*temporary_alloc)(size_t),
                           void (*temporary_free)(void *),
                           void (*before_loading_interface)(void),
                           void (*after_loading_interface)(void),
                           char *source_filename, void *target){
  unsigned i;
  for(i = 0; i < number_of_file_functions_in_the_list; i ++){
    if(!strcmp(list_of_file_functions[i].extension, ext))
      return list_of_file_functions[i].load_texture;
  }
  return NULL;
}
@

The code above is verbose because it defines a function that returns a
function pointer---with many parameters. However, the function itself
takes only a single argument: \monoespaco{ext}, a file extension to be
searched for in the list.

Since we use a function to compare strings, we must include the
standard header for string operations:

@<Local Headers (interface.c)@>=
#include <string.h>
@

Now we can define the initialization function. This function will set
the six basic custom functions, count how many additional custom
functions are provided to interpret files, allocate the necessary
space in the list above (using the custom allocation functions), and
fill the newly allocated list accordingly:

@<API Functions Definition (interface.c)@>=
void _Winit_interface(int *window_width_p, int *window_height_p,
                      void *(*new_permanent_alloc)(size_t),
                      void (*new_permanent_free)(void *),
                      void *(*new_temporary_alloc)(size_t),
                      void (*new_temporary_free)(void *),
                      void (*new_before_loading_interface)(void),
                      void (*new_after_loading_interface)(void), ...){
  if(new_permanent_alloc != NULL) /* Part 1: Get 6 functions + window size*/
    permanent_alloc = new_permanent_alloc;
  if(new_temporary_alloc != NULL)
    temporary_alloc = new_temporary_alloc;
  permanent_free = new_permanent_free;
  temporary_free = new_temporary_free;
  before_loading_interface = new_before_loading_interface;
  after_loading_interface = new_after_loading_interface;
  window_width = window_width_p;
  window_height = window_height_p;
  {
    int count = -1, i; /* Part 2: How many more functions there are? */
    va_list args;
    char *ext;
    va_start(args, new_after_loading_interface);
    do{
      count ++;
      ext = va_arg(args, char *);
      va_arg(args, pointer_to_interface_function*);
    } while(ext != NULL);
    number_of_file_functions_in_the_list = count;
    list_of_file_functions = (struct file_function *)
                               permanent_alloc(sizeof(struct file_function) * 
                                               count); //Part 3:Allocate others
    va_start(args, new_after_loading_interface);
    for(i = 0; i < count; i ++){
      list_of_file_functions[i].extension = va_arg(args, char *);
      list_of_file_functions[i].load_texture =
                          va_arg(args, pointer_to_interface_function*);
    }
  }
  @<Initializing Interface API@>
}
@

The function above is quite verbose because C tends to be verbose when
dealing with functions that accept a variable number of arguments,
especially when those arguments are pointers to functions with many
parameters. Despite the verbosity, the initialization logic is
straightforward.

At the end, in red, we marked a placeholder where we will insert
additional initialization code, which will be defined in the following
sections.

The use of certain features---such as accessing arguments via
\monoespaco{va\_list}---requires the inclusion of the following header:

@<Local Headers (interface.c)@>=
#include <stdarg.h>
@

\subsecao{3.2. Finalization}

The function that complements our initialization is the finalization
function. If, during initialization, we allocate memory to store a
list of functions that interpret files, then during finalization we
begin by deallocating that memory. Similarly, if initialization
involves setting the six basic custom functions, finalization resets
those functions to their default initial values:

@<API Functions Definition (interface.c)@>+=
void _Wfinish_interface(void){
  @<Finalizing Interface API@>
  if(permanent_free != NULL)
    permanent_free(list_of_file_functions);
  number_of_file_functions_in_the_list = 0;
  permanent_alloc = malloc;
  temporary_alloc = malloc;
  permanent_free = free;
  temporary_free = free;
  before_loading_interface = NULL;
  after_loading_interface = NULL;
}
@

Note that we have reserved additional space, marked in red, for code
that may be needed later in the finalization process as the API grows
in complexity with the addition of new functions in the following
sections.

This finalization function undoes everything performed during
initialization. It is safe to initialize and finalize the API
repeatedly without issues.

\secao{4. Shaders}

One of the things we need to define is our default shader to be used
if the user does not provide a custom shader when creating an
interface. Defining the custom shader gives us a great opportunity to
present in more detail the requirements for shaders supported by this
API. We will require a specific format for shaders.

First, all shader source files must specify the shading language
version on the first line. We use the GLSL language, which has
different versions. We will not require the user to include this
information in every shader source, as we will insert it
automatically.

To choose the correct GLSL version to use in all shaders, we check the
value of the macro \monoespaco{W\_GLSL\_VERSION}. This macro will be
written as the first line of each shader source code. The macro can be
defined by the user via appropriate compilation flags or by including
the macro definition in the code. If it is not defined, we will use
the default string ``\monoespaco{\#version 100\\n}''. This standard
value corresponds to the OpenGL ES shading language version 1.00. We
will define the macro at the beginning of the file that contains our
functions if it does not already exist:

@<Local Macros (interface.c)@>=
#if !defined(W_GLSL_VERSION)
#define W_GLSL_VERSION "#version 100\n"
#endif
@

There is at least two different shaders that we need to define for
each interface. The first is the vertex shader, that will be processed
for each vertex in our interface. The other is the fragment shader,
that will process each individual pixel. Each of them have a different
source code. But as we defined in the Introduction, when we specify a
shader to each interface passing a single filename with its source
code. We do not pass two fileames. How can we represent two source
codes in the same file?

Well, as the GLSL language support C-like macros, we can do this in
the same way that we can create a program in C that will run in both
Windows and Linux. We use conditional macros to include conditionally
custom source code for each environment. For this, we must have two
different GLSL macros. One that will be defined when we need a vertex
shader and the other when we need a fragment shader:

@<Local Variables (interface.c)@>+=
static const char vertex_shader_macro[] = "#define VERTEX_SHADER\n";
static const char fragment_shader_macro[] = "#define FRAGMENT_SHADER\n";
@

In the shader source code, we only need to check which macro is
defined, allowing us to include code conditionally based on that.

Next, we need to specify the default precision for each variable type
if the user does not specify one in the variable declaration. This is
done using the keyword precision followed by a precision qualifier
(\monoespaco{lowp}, \monoespaco{mediump}, \monoespaco{highp}) and a
variable type. Here, we will set the highest possible precision as the
default. For less critical variables, the user can always lower the
precision to make the shader more efficient.

@<Local Variables (interface.c)@>+=
static const char precision_qualifier[] = "precision highp float;\n"
                                          "precision highp int;\n";
@

The next thing we must define is how to support libraries in our GLSL
code. These libraries can simplify shader definitions. The user can
define additional GLSL functions that will be available in all
interface shaders by storing their source code in the following
variable:

@<Local Variables (interface.c)@>+=
static char *shader_library = "";
@

The variable will be modified by the function introduced in the
Introduction to extend GLSL with new functions. This function is
extremely simple: it just assigns a string containing the function’s
source code to the variable mentioned above:

@<API Functions Definition (interface.c)@>+=
void _Wset_interface_shader_library(char *src){
  shader_library = src;
}
@

However, we should not forget that when finalizing our API, we need to
undo this assignment. Otherwise, if a user finalizes and then
initializes the API again, the second initialization would have the
same function definitions assigned as in the first initialization:

@<Finalizing Interface API@>=
shader_library = "";
@

The list of default variables and attributes passed to the shader must
also be included in the source code. We will define them later, but
for now, we show that they will be stored in this variable:

@<Local Variables (interface.c)@>+=
static const char shader_variables[] = ""
@<Shader Attributes, Uniforms and Varyings@>
"";
@

Now we will see how to compile a shader given this information and a
string containing its source code. First, we include the standard
input/output library to print error messages on the screen if there
are errors in the shader source code. The OpenGL headers are already
included in \monoespaco{interface.h}.

@<Local Headers (interface.c)@>+=
#if defined(__linux__) || defined(BSD)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#endif
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
#include <stdio.h>
@

Once we have the necessary headers, we can define the function that,
given a shader source code, compiles it into a complete shader
program. Compiling a shader involves creating both types of shaders
(vertex and fragment) in OpenGL, compiling them, and linking them into
a single program.

@<Auxiliary Local Functions (interface.c)@>=
@<Functions to Check Compiling Errors@>
static GLuint compile_shader(const char *source_code){
  GLuint vertex_shader, fragment_shader, program;
  const char *list_of_source_code[6];
  vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
  list_of_source_code[0] = W_GLSL_VERSION;
  list_of_source_code[1] = vertex_shader_macro;
  list_of_source_code[2] = precision_qualifier;
  list_of_source_code[3] = shader_library;
  list_of_source_code[4] = shader_variables;
  list_of_source_code[5] = source_code;
  glShaderSource(vertex_shader, 6, list_of_source_code, NULL);
  list_of_source_code[1] = fragment_shader_macro;
  glShaderSource(fragment_shader, 6, list_of_source_code, NULL);
  glCompileShader(vertex_shader);
  if(check_compiling_error(vertex_shader))
    return 0;
  glCompileShader(fragment_shader);
  if(check_compiling_error(fragment_shader))
    return 0;
  program = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);
  if(check_linking_error(program))
    return 0;
  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);
  return program;
}
@

What we did not show above is how we verify whether the shader was
compiled and linked successfully. To check for shader compilation
errors, we use the function below. It checks if a compilation error
occurred, and if so, it reads the logs to determine what went wrong
and prints the message to the screen. Note that here we use the
temporary allocation and deallocation functions to manage memory space
for the error message. The function also returns whether an error was
found.

@<Functions to Check Compiling Errors@>=
static bool check_compiling_error(GLuint shader){
  GLint status;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    int info_log_length;
    char *error_msg;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetShaderInfoLog(shader, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
  return false;
}
@

Checking whether an error occurred during the linking stage is
similar. However, after linking, we can go even further: we can try to
validate the shader by simulating its usage to detect additional
errors that could not be caught during syntactic analysis. However,
since this is an expensive operation, we will perform it only if the
macro \monoespaco{W\_DEBUG\_INTERFACE} is defined. In that case, we
assume we are in debug mode.

@<Functions to Check Compiling Errors@>+=
static bool check_linking_error(GLuint program){
  GLint status;
  GLsizei info_log_length;
  char *error_msg;
  glGetProgramiv(program, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#if defined(W_DEBUG_INTERFACE)
  glValidateProgram(program);
  glGetProgramiv(program, GL_VALIDATE_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#endif
  return false;  
}
@

This concludes the explanation of how we compile a new shader and
print messages when errors are found in the source code.

Now we can define the default shader source code that will be used if
the user does not provide a custom shader. The goal of this shader is
to display the texture associated with the interface.

The source code for the default shader will be stored in the following
constant:

@<Local Variables (interface.c)@>+=
static const char default_shader_source[] = ""
"#if defined(VERTEX_SHADER)\n"
@<Default Vertex Shader@>
"#else\n"
@<Default Fragment Shader@>
"#endif\n"
"";
@

The source code will consist of string literals stored in the constant
variable defined above. In the case of the vertex shader, it will
multiply each vertex by the model-view matrix, which contains
information about the interface’s size, position, and rotation. It
will also assign a texture coordinate to each vertex.

To understand the code, keep in mind that all interfaces will share
the same vertices: $(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0)$. Each
vertex is associated with a texture coordinate, as declared below:

@<Local Variables (interface.c)@>+=
static const float interface_vertices[20] = {
  0.0, 0.0, 0.0, // First Vertice
  0.0, 0.0,     // Texture coordinate
  1.0, 0.0, 0.0, // Second vertice
  1.0, 0.0,     // Texture coordinate
  1.0, 1.0, 0.0,  // Third Vertice
  1.0, 1.0,      // Texture coordinate
  0.0, 1.0, 0.0, // Fourth vertice
  0.0, 1.0};    // Texture coordinate
static GLuint interface_vbo;
@

The order in which we declare these vertices is important. When
followed in the declared order, they form a square in
counter-clockwise order. This tells OpenGL that we are viewing the
front of the interface, not its back. We do this to account for the
possibility that the user configures OpenGL to not render the back
faces of geometric figures—an optimization that is very common and
often necessary. By specifying the correct order, we ensure that the
interface remains visible even when this option is enabled.

The rotated texture coordinates are used if the macro
\monoespaco{W\_FORCE\_LANDSCAPE} is defined and the window height is
greater than its width. In this case, we swap the interface’s width
and height and also rotate the texture. This effectively rotates the
interface.

These vertices will be loaded into the video card, and afterward we
can render them by drawing the corresponding VBO (Vertex Buffer
Object). Loading the vertices into the VBO is done during
initialization:

@<Initializing Interface API@>+=
glGenBuffers(1, &interface_vbo);
glBindBuffer(GL_ARRAY_BUFFER, interface_vbo);
// Sending vertices to the video card:
glBufferData(GL_ARRAY_BUFFER, sizeof(interface_vertices), interface_vertices,
             GL_STATIC_DRAW);
@

During finalization, we need to destroy the VBO:

@<Finalizing Interface API@>+=
glDeleteBuffers(1, &interface_vbo);
@

By default, all interfaces start as a rectangle centered on the
screen, occupying the entire screen area, since OpenGL defines “1” as
the width and height of the rendering space. To transform this fixed
square into different sizes, positions, and rotations, we use
model-view matrices. Each interface will have its own model-view
matrix.

@<Default Vertex Shader@>=
"void main(){\n"
"  gl_Position = model_view_matrix * vec4(vertex_position, 1.0);\n"
"  texture_coordinate = vertex_texture_coordinate;\n"
"}\n"
@

In the fragment shader, for each pixel, we will draw the color
associated with the texture at a given position:

@<Default Fragment Shader@>=
"void main(){\n"
"  vec4 texture = texture2D(texture1, texture_coordinate);\n"
"  gl_FragData[0] = texture;\n"
"}\n"
@

Now we need to define the attributes, uniforms, and varyings used in
the shaders. Attributes are read-only data specified for each
vertex. The attributes we will define include the vertex position in
the format $(x, y, z)$ and the texture coordinate in the format $(x,
y)$. The $x$ and $y$ coordinates will range from 0 to 1, with $z = 0$,
as previously described. Attributes are declared only in vertex
shaders.

@<Shader Attributes, Uniforms and Varyings@>=
"#if defined(VERTEX_SHADER)\n"
"attribute vec3 vertex_position;\n"
"attribute vec2 vertex_texture_coordinate;\n"
"#endif\n"
@

Uniforms are variables that are also passed to vertices but do not
change between them. Therefore, the fragment shader does not need to
interpolate their values. We will store the following as uniforms: the
foreground color, the background color, the model-view matrix, the
object size in pixels, the current time in seconds, the integer
associated with each interface, and its texture:

@<Shader Attributes, Uniforms and Varyings@>+=
"uniform vec4 foreground_color, background_color;\n"
"uniform mat4 model_view_matrix;\n"
"uniform vec2 interface_size;\n"
"uniform vec2 mouse_coordinate;\n"
"uniform float time;\n"
"uniform int integer;\n"
"uniform sampler2D texture1;\n"
@

Finally, we have varying variables. They can be set and modified in
the vertex shader, and their interpolated values will be passed to the
fragment shader. Here, we use them for the texture coordinates.

@<Shader Attributes, Uniforms and Varyings@>+=
"varying mediump vec2 texture_coordinate;\n"
@

Note that we did not use all the variables defined in the default
shader. Unused variables will be discarded during compilation as an
optimization. However, we declared them anyway to list the supported
variables that can be used by custom shaders defined by the user.

By the way, speaking of custom shaders, they will be provided by the
user through the function \monoespaco{\_Wnew\_interface} and specified
as a path to a file containing the source code. For this case, we will
define a function that creates a new shader program from a filename
given as an argument:

@<Auxiliary Local Functions (interface.c)@>=
static GLuint compile_shader_from_file(const char *filename){
  char *buffer;
  size_t source_size, ret;
  FILE *fp;
  GLuint shader_program;
  fp = fopen(filename, "r");
  if(fp == NULL)  return 0;
  // Go to end of file to get its size and return to beginning:
  fseek(fp, 0, SEEK_END);
  source_size = ftell(fp);
  // Allocates and reads buffer:
  buffer = (char *) temporary_alloc(sizeof(char) * (source_size + 1));
  if(buffer == NULL) return 0;
  do{
    rewind(fp);
    ret = fread(buffer, sizeof(char), source_size, fp);
  } while(feof(fp) && !ferror(fp) && ret / sizeof(char) == source_size);
  buffer[source_size] = '\0';
  shader_program = compile_shader(buffer);
  if(temporary_free != NULL) temporary_free(buffer);
  return shader_program;
}
@

The last problem we will address in this section is what should be
rendered as the default texture when the user supplies no texture for
a given interface. In these cases, we will create a texture composed
of a single white pixel:

@<Local Variables (interface.c)@>+=
static GLuint default_texture;
@

We will create this texture during initialization. The following code
generates the texture in OpenGL, binds it as the current 2D texture,
and specifies the white pixel, explaining how it is represented.

@<Initializing Interface API@>+=
{
  GLubyte pixels[3] = {255, 255, 255};
  glGenTextures(1, &default_texture);
  glBindTexture(GL_TEXTURE_2D, default_texture);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE,
               pixels);
}
@


During finalization we discard the created texture:

@<Finalizing Interface API@>+=
glDeleteTextures(1, &default_texture);
@

\secao{5. The Model-View Matrix}

As we have seen, all interfaces are represented by four vertices
forming a square with fixed edge length of 1. What determines each
interface's size, position, and rotation is the model-view matrix
applied to it.

To understand this matrix, recall that in our default vertex shader
(shown earlier), each vertex is converted to a four-dimensional point
instead of a two- or three-dimensional one. The line
\monoespaco{vec4(vertex\_position, 1.0)} takes the 3D coordinates and
adds a fourth component with a value of 1.

This is necessary because only in four dimensions can translation,
rotation, and scaling all be represented as matrix multiplications. In
other words, only in 4D are these operations linear. Since GPUs are
highly optimized for matrix multiplications, representing these
transformations any other way would harm performance.

Before presenting the final form of the model-view matrix, we will
first look at its individual components. Suppose we have a
four-dimensional vector $(x0,y0,z0,1)$ and want to apply only a
translation to it. In this case, we can multiply it by the translation
matrix shown below:

$$ \left[{{1 \atop 0}\atop {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{x \atop y}\atop{0\atop
      1}}\right]\left[{{x_0\atop y_0}\atop {z_0\atop
      1}}\right]=\left[{{1x_0+0y_0+0z_0+x\atop 0x_0+1y_0+0z_0+y}\atop
    {0x_0+0y_0+1z_0+0\atop
      0x_0+0y_0+0z_0+1}}\right]=\left[{{x_0+x\atop y_0+y}\atop
    {z_0\atop 1}}\right]
$$

To change the size of an interface---both its width and
height—assuming the interface is centered at the origin
$(0,0,0,1)$, we can multiply each vertex vector by the
following scaling matrix:

$$ \left[{{w \atop 0}\atop {0\atop 0}}{{0 \atop h}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]\left[{{x_0\atop y_0}\atop {z_0\atop
      1}}\right]=\left[{{wx_0+0y_0+0z_0+0\atop 0x_0+hy_0+0z_0+0}\atop
    {0x_0+0y_0+1z_0+0\atop 0x_0+0y_0+0z_0+1}}\right]=\left[{{wx_0\atop
      hy_0}\atop {z_0\atop 1}}\right]
$$

And finally, to rotate our interface by $\theta$ radians, we can use
the following matrix, which produces the correct result based on the
trigonometric formulas for rotation:

$$ \left[{{cos(\theta) \atop \sin(\theta)}\atop {0\atop
      0}}{{-sin(\theta) \atop cos(\theta)}\atop {0 \atop 0}}{{0\atop
      0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]\left[{{x_0\atop y_0}\atop {z_0\atop
      1}}\right]=\left[{{x_0 cos(\theta)-y_0 sin(\theta)+0z_0+0\atop
      x_0 sin(\theta)+y_0 cos(\theta)+0z_0+0}\atop
    {0x_0+0y_0+1z_0+0\atop 0x_0+0y_0+0z_0+1}}\right]=\left[{{x_0
      cos(theta) - y_0 sin(\theta) \atop x_0 sin(\theta) + y_0
      cos(\theta)}\atop {z_0\atop 1}}\right]
$$

To form our model-view matrix, we multiply all the matrices
corresponding to the desired scale, rotation, and
translation. However, the order in which these matrices are multiplied
affects the final result. The correct sequence of operations is:

1. First, we center the interface square at the OpenGL origin. (Matrix
A).

2. Then, we scale the interface based on its pixel dimensions. (Matrix
B)

3. We rotate the interface by $\theta$ radians. (Matrix C)

4. We scale the interface again, this time adjusting it to the screen
proportions using OpenGL coordinates. (Matrix D)

5. Finally, we translate the interface to its correct position using
OpenGL coordinates. (Matrix E)

To perform these operations in the correct order, each vector $v$
should be multiplied as follows:

$$
E(D(C(B(A v)))) = ((((ED)C)B)A)v
$$

If we use a different order, the transformations may not behave as
expected. For example, instead of rotating the interface around its
center, we might end up rotating it around its lower-left corner or
some other unintended point.

To avoid always needing to multiply all four matrices at runtime, we
will compute the final matrix format resulting from their
multiplication. This final matrix will be our model-view matrix. For
instance, assuming that wwww​ is the window width and hwhw​ is the
window height, by multiplying matrices $E$ and $D$, we obtain:

$$ ED=\left[{{1 \atop 0}\atop {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{x \atop y}\atop{0\atop
      1}}\right]\left[{{2/w_w \atop 0}\atop {0\atop 0}}{{0 \atop
      2/h_w}\atop {0 \atop 0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop
      0}\atop{0\atop 1}}\right]=
\left[{{2/w_w \atop 0}\atop {0\atop 0}}
  {{0 \atop 2/h_w}\atop {0 \atop 0}}
  {{0\atop 0}\atop{1 \atop 0}}
  {{x \atop y}\atop{0\atop 1}}\right]
$$

Note that we are using $2/w_w$​ and $2/h_w$​ because we assume the
OpenGL coordinate system has a total width and height of 2. Therefore,
an object with a width equal to $w_w$​ must be scaled to width 2 in
OpenGL units to occupy the entire screen. The same reasoning applies
to the height.

If we now multiply this result by matrix $C$, we obtain:


$$
EDC = \left[{{2/w_w \atop 0}\atop {0\atop 0}} {{0 \atop 2/h_w}\atop
  {0 \atop 0}} {{0\atop 0}\atop{1 \atop 0}} {{x \atop y}\atop{0\atop
  1}}\right]\left[{{cos(\theta) \atop \sin(\theta)}\atop {0\atop
  0}}{{-sin(\theta) \atop cos(\theta)}\atop {0 \atop 0}}{{0\atop
  0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop 1}}\right] =
\left[{{2/w_w\cdot cos(\theta) \atop 2/h_w\cdot sin(\theta)}
\atop {0\atop 0}}
  {{-2/w_w\cdot sin(\theta) \atop 2/h_w\cdot cos(\theta)}\atop
  {0 \atop 0}} {{0\atop 0}\atop{1 \atop 0}} {{x \atop y}\atop{0\atop
  1}}\right]
$$

Now, if we multiply the result by matrix $B$, considering that $h_p$​
is the object’s height in pixels and $w_p$ is its width in pixels, we
obtain:

$$ EDCB =
\left[{{2/w_w\cdot cos(\theta) \atop 2/h_w\cdot sin(\theta)}
\atop {0\atop 0}}
  {{-2/w_w\cdot sin(\theta) \atop 2/h_w\cdot cos(\theta)}\atop
  {0 \atop 0}} {{0\atop 0}\atop{1 \atop 0}} {{x \atop y}\atop{0\atop
  1}}\right]\left[{{w_p \atop 0}\atop {0\atop 0}}{{0 \atop h_p}\atop
  {0 \atop 0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
  1}}\right]=
\left[{{2w_p/w_w\cdot cos(\theta) \atop 2w_p/h_w\cdot sin(\theta)}
\atop {0\atop 0}}
  {{-2h_p/w_w\cdot sin(\theta) \atop 2h_p/h_w\cdot cos(\theta)}\atop
  {0 \atop 0}} {{0\atop 0}\atop{1 \atop 0}} {{x \atop y}\atop{0\atop
  1}}\right]
$$

And finally, we multiply this by matrix $A$, which centers the
interface at $(0,0,0,1)$. Recall that the interface is
originally centered at position $(1/2,1/2,0,1)$. Therefore,
matrix $A$ is simply a translation matrix with constant values that
shift each vertex 1/2 unit to the left and 1/2 unit down:

$$
EDCBA =\left[{{2w_p/w_w\cdot cos(\theta) \atop 2w_p/h_w\cdot sin(\theta)}
\atop {0\atop 0}}
  {{-2h_p/w_w\cdot sin(\theta) \atop 2h_p/h_w\cdot cos(\theta)}\atop
  {0 \atop 0}} {{0\atop 0}\atop{1 \atop 0}} {{x \atop y}\atop{0\atop
  1}}\right]
\left[{{1 \atop 0}\atop {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{-1/2 \atop -1/2}\atop{0\atop
      1}}\right]=
$$

$$
=\left[{{2w_p/w_w\cdot cos(\theta) \atop 2w_p/h_w\cdot sin(\theta)}
\atop {0\atop 0}}
  {{-2h_p/w_w\cdot sin(\theta) \atop 2h_p/h_w\cdot cos(\theta)}\atop
  {0 \atop 0}} {{0\atop 0}\atop{1 \atop 0}} {{x+h_p/w_w\cdot
  sin(\theta)-w_p/w_w\cdot cos(\theta) \atop y-w_p/h_w\cdot
  sin(\theta)-h_p/h_w\cdot cos(\theta)}\atop{0\atop 1}}\right]
$$

The format shown above is the final form of the model-view matrix for
each interface.

However, the $(x,y)$ values above are in OpenGL coordinates. In our
API, coordinates are measured differently: the origin is at the
lower-left corner of the screen, not at the center as in
OpenGL. Additionally, positions are measured in pixels rather than
using the fixed size of 2 for the screen as OpenGL does. Therefore, a
function that fills the model-view matrix must first convert our
coordinates and sizes to OpenGL format.

Assuming we have a pointer \monoespaco{i} to a given interface, this
conversion can be done with the following code:

@<Converting Coordinates and Sizes@>=
x = 2.0 * (i -> _x) / (*window_width) - 1.0;
y = 2.0 * (i -> _y) / (*window_height) - 1.0;
@

Using the conversion rules above, we can fill the model-view matrix
for the first time with the function below:

@<Auxiliary Local Functions (interface.c)@>=
static void initialize_model_view_matrix(struct user_interface *i){
  GLfloat x, y;
  @<Converting Coordinates and Sizes@>
  GLfloat cos_theta = cos(i -> _rotation);
  GLfloat sin_theta = sin(i -> _rotation);
  /* Primeira Coluna */
  i -> _transform_matrix[0] = (2 * i -> width / (*window_width)) *
    cos_theta;
  i -> _transform_matrix[1] = (2 * i -> width / (*window_height)) *
    sin_theta;
  i -> _transform_matrix[2] = 0.0;
  i -> _transform_matrix[3] = 0.0;
  /* Segunda Coluna */
  i -> _transform_matrix[4] = -(2 * i -> height / (*window_width)) *
     sin_theta;
  i -> _transform_matrix[5] = (2 * i -> height / (*window_height)) *
    cos_theta;
  i -> _transform_matrix[6] = 0.0;
  i -> _transform_matrix[7] = 0.0;
  /* Terceira Coluna */
  i -> _transform_matrix[8] = 0.0;
  i -> _transform_matrix[9] = 0.0;
  i -> _transform_matrix[10] = 1.0;
  i -> _transform_matrix[11] = 0.0;
  /* Quarta Coluna */
  i -> _transform_matrix[12] = x +
    (i -> height / (*window_width)) * sin_theta -
    (i -> width / (*window_width)) * cos_theta;
  i -> _transform_matrix[13] = y -
    (i -> width / (*window_height)) * sin_theta -
    (i -> height / (*window_height)) * cos_theta;
  i -> _transform_matrix[14] = 0.0;
  i -> _transform_matrix[15] = 1.0;
}
@

Using the sine and cosine functions requires including the header for
mathematical operations:

@<Local Headers (interface.c)@>+=
#include <math.h>
@

\secao{6. Managing Data Structures}

As explained and defined before, the data structures managed by our
API include: a struct for interfaces, another for linking interfaces,
a third for creating history markers, and finally, a linked list to
store these structures.

Our linked list will be accessed using two different pointers. The
first points to the most recently created and inserted structure in
the list. The second points to the most recent history marker inserted
in the list. We will also define a mutex to ensure that only one
thread can update the linked list at any given time:

@<Local Variables (interface.c)@>+=
static void *last_structure = NULL;
static struct marking *last_marking = NULL;
_STATIC_MUTEX_DECLARATION(linked_list_mutex);
@

The mutex that will control access to the linked list needs to be
created during initialization:

@<Initializing Interface API@>+=
MUTEX_INIT(&linked_list_mutex);
@

We will include the code to finalize this mutex later, when we define
the code that finalizes the entire linked list.

\subsecao{6.1. Creating and Destroying Shader Data Structures}

In Section 4, we presented the default shader source code and how to
compile shaders. However, we did not integrate those functions and
data structures with the shader data structure. We will do that here
in this section.

Our API does not have an exported function to create new
shaders. Instead, it creates new shaders when the user creates a new
interface and associates it with a custom shader by passing a filename
containing the shader source code. That is, when the user calls the
API function \monoespaco{\_Wnew\_interface} with the second parameter
specifying a filename with shader source code different from
\monoespaco{NULL}.

We also need to create a structure for our default shader, whose
source code is in Section 4. The address of the default shader
structure will be stored in this pointer:

@<Local Variables (interface.c)@>+=
struct shader *default_shader;
@

Now we will define the internal function that generates new shader
structures. This function receives as an argument a string with the
filename that contains the shader source code. The function returns a
pointer to the new shader structure and also inserts this data
structure into the linked list—except when \monoespaco{NULL} is passed
as the filename. In that case, a new shader structure is created using
the default shader source code defined in Section 4, and it is not
inserted into the linked list.

@<Auxiliary Local Functions (interface.c)@>+=
static struct shader *new_shader(char *shader_source){
  struct shader *new = (struct shader *) permanent_alloc(sizeof(struct shader));
  if(new != NULL){
    new -> type = TYPE_SHADER;
    new -> next = NULL;
    if(shader_source == NULL)
      new -> program = compile_shader(default_shader_source);
    else
      new -> program = compile_shader_from_file(shader_source);
    // Binding attributes
    glBindAttribLocation(new -> program, 0, "vertex_position");
    glBindAttribLocation(new -> program, 1, "vertex_texture_coordinate");
    // Getting uniforms
    new -> uniform_foreground_color =  glGetUniformLocation(new -> program,
                                                            "foreground_color");
    new -> uniform_background_color =  glGetUniformLocation(new -> program,
                                                            "background_color");
    new -> uniform_model_view_matrix = glGetUniformLocation(new -> program,
                                                            "model_view_matrix");
    new -> uniform_interface_size = glGetUniformLocation(new -> program,
                                                         "interface_size");
    new -> uniform_mouse_coordinate = glGetUniformLocation(new -> program,
                                                         "mouse_coordinate");
    new -> uniform_time = glGetUniformLocation(new -> program, "time");
    new -> uniform_integer = glGetUniformLocation(new -> program, "integer");
    new -> uniform_texture1 = glGetUniformLocation(new -> program, "texture1");
    if(shader_source != NULL){ // Insere na lista encadeada:
      MUTEX_WAIT(&linked_list_mutex); // Preparando mutex
      if(last_structure != NULL)
        ((struct user_interface *) last_structure)-> next = (void *) new;
      last_structure = (void *) new;
      MUTEX_SIGNAL(&linked_list_mutex);
    }
  }
  return new;
}
@

Basically, the code above uses the functions defined in Section 4 to
compile the shader. After compiling it, the code obtains the addresses
of the compiled shader variables that can be modified before executing
the shader. These addresses are stored in the shader data structure.

Now, we can initialize the default shader during Initialization:

@<Initializing Interface API@>+=
default_shader = new_shader(NULL);
@

To destroy a shader, we need to notify that the compiled shader
program will no longer be executed and should be deleted. Then, we
deallocate the memory allocated for the struct:

@<Auxiliary Local Functions (interface.c)@>+=
static void destroy_shader(struct shader *shader_struct){
  glDeleteProgram(shader_struct -> program);
  if(permanent_free != NULL)
    permanent_free(shader_struct);
}
@

The default shader should be destroyed in the API finalization:

@<Finalizing Interface API@>+=
destroy_shader(default_shader);
@

\subsecao{6.2. Creating and Destroying Interfaces}

As described in the Introduction, all new interfaces will be created
using the function \monoespaco{\_Wnew\_interface}. This function will
allocate the new interface, execute the appropriate functions to
initialize it, and include it in the linked list. The function is
defined as follows:

@<API Functions Definition (interface.c)@>+=
struct user_interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float z, float width,
                                  float height){
  struct user_interface *new_interface;
  void (*loading_function)(void *(*permanent_alloc)(size_t),
                           void (*permanent_free)(void *),
                           void *(*temporary_alloc)(size_t),
                           void (*temporary_free)(void *),
                           void (*before_loading_interface)(void),
                           void (*after_loading_interface)(void),
                           char *source_filename, void *target);
  int i;
  new_interface = permanent_alloc(sizeof(struct user_interface));
  if(new_interface != NULL){
    new_interface -> type = TYPE_INTERFACE;
    new_interface -> next = NULL;
    new_interface-> x = new_interface-> _x = x;
    new_interface -> y = new_interface-> _y = y;
    new_interface -> rotation = new_interface -> _rotation = 0;
#if defined(W_FORCE_LANDSCAPE)
   if(*window_height > *window_width){
      new_interface-> _x = *window_width - y;
      new_interface -> _y = x;
      new_interface -> _rotation += M_PI_2;
   }
#endif
    new_interface -> z = z;
    new_interface -> width = width;
    new_interface -> height = height;
    for(i = 0; i < 4; i ++){
      new_interface -> background_color[i] = 0.0;
      new_interface -> foreground_color[i] = 0.0;
    }
    new_interface -> integer = 0;
    new_interface -> visible = true;
    initialize_model_view_matrix(new_interface);
    if(shader_filename != NULL)
      new_interface -> shader_program = new_shader(shader_filename);
    else
      new_interface -> shader_program = default_shader;
    new_interface -> _texture1 = NULL;
    if(filename != NULL) // Still need to load texture:
      new_interface -> _loaded_texture = false;
    else // No texture to be loaded:
      new_interface -> _loaded_texture = true;
    new_interface -> animate = false;
    new_interface -> number_of_frames = 1;
    new_interface -> current_frame = 0;
    new_interface -> frame_duration = NULL;
    new_interface -> _t = 0;
    new_interface -> max_repetition = 0;
    MUTEX_INIT(&(new_interface -> mutex));
    new_interface -> _mouse_over = false;
    new_interface -> on_mouse_over = NULL;
    new_interface -> on_mouse_out = NULL;
    new_interface -> on_mouse_left_down = NULL;
    new_interface -> on_mouse_left_up = NULL;
    new_interface -> on_mouse_middle_down = NULL;
    new_interface -> on_mouse_middle_up = NULL;
    new_interface -> on_mouse_right_down = NULL;
    new_interface -> on_mouse_right_up = NULL;
    new_interface -> _internal_data = NULL;
    new_interface -> _free_internal_data = NULL;
    new_interface -> _reload_texture = NULL;
    MUTEX_WAIT(&linked_list_mutex); // Inserindo na lista encadeada
    if(last_structure != NULL)
      ((struct user_interface *) last_structure)-> next = (void *) new_interface;
    last_structure = (void *) new_interface;
    last_marking -> number_of_interfaces ++;
    MUTEX_SIGNAL(&linked_list_mutex);
    if(filename != NULL){ // Get and run loading function:
      char *ext;
      for(ext = filename; *ext != '\0'; ext ++);
      for(; *ext != '.' && ext != filename; ext --);
      if(*ext == '.'){
        ext ++;
        loading_function = get_loading_function(ext);
        if(loading_function != NULL)
          loading_function(permanent_alloc, permanent_free, temporary_alloc,
                           temporary_free, before_loading_interface,
                           after_loading_interface, filename, new_interface);
      }
    }
  }
  return new_interface;
}
@

Despite being a long function, what it does is simply allocate the
interface using the function set as our permanent allocator,
initialize the interface’s variables, insert it into the linked list,
and run the appropriate function to load the texture, depending on the
filename extension.

Destroying an interface means checking whether some of its variables
are different from \monoespaco{NULL}. If so, it means these variables
were allocated by the loading function and should also be
deallocated. Examples of such variables include the texture and the
list of frame durations for animated textures. The destructor function
must first deallocate these variables, and only then deallocate the
entire struct:

@<Auxiliary Local Functions (interface.c)@>+=
static void destroy_interface(struct user_interface *interface_struct){
  if(interface_struct -> _texture1 != NULL){
    glDeleteTextures(interface_struct -> number_of_frames,
                     interface_struct -> _texture1);
    if(permanent_free != NULL)
      permanent_free(interface_struct -> _texture1);
  }
  if(interface_struct -> frame_duration != NULL && permanent_free != NULL)
    permanent_free(interface_struct -> frame_duration);
  MUTEX_DESTROY(&(interface_struct -> mutex));
  if(interface_struct -> _free_internal_data != NULL &&
     interface_struct -> _internal_data != NULL){
    interface_struct -> _free_internal_data(interface_struct -> _internal_data);
  }
  if(permanent_free != NULL)
    permanent_free(interface_struct);
}
@

\subsecao{6.3. Creating and Destroying Link to an Existing Interface}

As explained, instead of creating a new interface, we can create a
link to an existing one. This causes the linked interface to behave as
if it were newly created, at least with respect to functions that
interact with it. A link is simply a pointer to another interface in
the linked list and is created using the function
\monoespaco{\_Wlink\_interface}. The function that creates it is defined
below:

@<API Functions Definition (interface.c)@>+=
struct user_interface *_Wlink_interface(struct user_interface *i){
  struct link *new_link = permanent_alloc(sizeof(struct link));
  if(new_link == NULL)
    return NULL;
  new_link -> type = TYPE_LINK;
  new_link -> next = NULL;
  new_link -> linked_interface = i;
  MUTEX_WAIT(&linked_list_mutex); // Inserindo na lista encadeada
  if(last_structure != NULL)
    ((struct user_interface *) last_structure)-> next = (void *) new_link;
  last_structure = (void *) new_link;
  last_marking -> number_of_interfaces ++;
  MUTEX_SIGNAL(&linked_list_mutex);
  return i;
}
@

Destroying a link is done simply by calling the deallocation
function. For this reason, we will not define an auxiliary function to
perform this action.

\subsecao{6.4. Creating Markers in the Interface History}

To create a new marker in the interface history, the user should call
the function \monoespaco{\_Wmark\_history\_interface}. Once this marker
is set, all interfaces created before it become inaccessible until the
marker is removed.

@<API Functions Definition (interface.c)@>+=
void _Wmark_history_interface(void){
  struct marking *new_marking = permanent_alloc(sizeof(struct marking));
  if(new_marking != NULL){
    new_marking -> type = TYPE_MARKING;
    new_marking -> next = NULL;
    new_marking -> previous_marking = last_marking;
    new_marking -> number_of_interfaces = 0;
    MUTEX_WAIT(&linked_list_mutex); // Inserindo na lista encadeada
    new_marking -> prev = last_structure;
    if(last_structure != NULL)
      ((struct user_interface *) last_structure)-> next = (void *) new_marking;
    last_structure = (void *) new_marking;
    last_marking = new_marking;
    MUTEX_SIGNAL(&linked_list_mutex);
  }
}
@

Since it is important to have at least one marker in the history to
keep track of the number of active interfaces, the first marker is
created during initialization and will only be removed during
finalization. If the user attempts to remove this initial marker using
the API function before finalization, the action will be ignored.

@<Initializing Interface API@>+=
_Wmark_history_interface();
@

@<Finalizing Interface API@>+=
// Erases all markings, except the first one:
while(last_marking -> previous_marking != NULL){
  _Wrestore_history_interface();
}
// Erase the interfaces after the first marking:
_Wrestore_history_interface();
// Erases the first marking:
if(permanent_free != NULL)
  permanent_free(last_marking);
last_marking = NULL;
last_structure = NULL;
MUTEX_DESTROY(&linked_list_mutex);
@

The function \monoespaco{\_Wrestore\_history\_interface} is an API
function that will be defined in the next section. It destroys and
removes all structures created after the most recent marker, and then
it removes and destroys that marker. However, it will never destroy
the initial marker. For this reason, in previous code, we manually
destroyed the first marker using \monoespaco{permanent\_free}.

\subsecao{6.5. Removing Markers and Interfaces}

We will remove and deallocate interfaces using the function that
restores the history to a previous point. This function will remove
all interfaces created after the most recent marker and then remove
that marker itself. This is handled by the function
\monoespaco{\_Wrestore\_history\_interface}.

After executing this function, the most recent marker will be removed,
and we will revert to the marker that existed before it. If there is
no previous marker, the current marker will not be removed, but the
system will still be restored to the state it had when the initial
marker was created.

The function is implemented as follows:

@<API Functions Definition (interface.c)@>+=
void _Wrestore_history_interface(void){
  struct marking *to_be_removed;
  struct user_interface *current, *next;
  MUTEX_WAIT(&linked_list_mutex);
  last_structure = last_marking -> prev;
  if(last_structure != NULL)
    ((struct user_interface *) last_structure) -> next = NULL;
  to_be_removed = last_marking;
  current = (struct user_interface *) to_be_removed -> next;
  // Removing interfaces after the last marking:
  while(current != NULL){
    next = (struct user_interface *) (current -> next);
    if(current -> type == TYPE_INTERFACE)
      destroy_interface(current);
    else if(current -> type == TYPE_SHADER)
      destroy_shader((struct shader *) current);
    else if(current -> type == TYPE_SOUND){
      //destroy_sound(snd);
    }
    else if(permanent_free != NULL)
      permanent_free(current);
    current = next;
  }
  // Removing last marker, except if it is also the first marking:
  if(to_be_removed -> previous_marking != NULL){
    last_marking = to_be_removed -> previous_marking;
    if(permanent_free != NULL)
      permanent_free(to_be_removed);
  }
  else
    to_be_removed -> number_of_interfaces = 0;
  MUTEX_SIGNAL(&linked_list_mutex);
}
@

The function first removes all structures created after the most
recent marker. Only after this is the last marker itself
removed---except when it is also the initial marker. The pointer to the
last structure in the linked list is updated at the beginning of the
function by retrieving the pointer to the previous element, which is
stored in the most recent marker that is being removed.

\secao{7. Rendering Interfaces}

To render interfaces, we must consider the correct order in which each
interface is drawn. One simple method is to draw the interfaces in any
order and use the $z$ coordinate and a $z$-buffer to determine whether
each interface should be drawn using a depth test. However, when
dealing with transparent objects, this approach does not always
produce the correct result. For example, if we first draw a
transparent object and then draw an opaque object behind it, parts of
the opaque object that should be visible through the transparency may
not be visible.

Since our interfaces are always two-dimensional objects parallel to
the $z$ axis, we instead maintain an ordered list of interfaces that
defines the correct drawing order. This list is ordered by the $z$
coordinate, ensuring that all interfaces are drawn before any
interface in front of them. This approach is essentially the
``painter’s algorithm'': just as a painter begins painting distant
objects first, we begin by drawing the most distant interfaces.

If two interfaces have the same $z$ coordinate value, they can be
drawn in any order.

The pointer storing the address of this ordered list is:

@<Local Variables (interface.c)@>+=
static struct user_interface **z_list = NULL;
static unsigned z_list_size = 0;
_STATIC_MUTEX_DECLARATION(z_list_mutex);
@

During the API initialization we should initialize the above
variables:

@<Initializing Interface API@>+=
MUTEX_INIT(&z_list_mutex);
z_list_size = 0;
z_list = NULL;
@

During the API initialization, we should initialize the variables
mentioned above:

@<Finalizing Interface API@>+=
MUTEX_DESTROY(&z_list_mutex);
if(z_list != NULL && permanent_free != NULL)
  permanent_free(z_list);
z_list = NULL;
z_list_size = 0;
@

As we did in the finalization, when we restore our interface history,
we change the list of interfaces that we are viewing, restoring
previous interfaces. In this case, we need to reset our list, making
it empty again.

@<Restoring History@>=
MUTEX_WAIT(&z_list_mutex);
if(z_list != NULL && permanent_free != NULL)
  permanent_free(z_list);
z_list = NULL;
z_list_size = 0;
MUTEX_SIGNAL(&z_list_mutex);
@

We must initialize this list in the rendering function
\monoespaco{\_Wrender\_interface}. Inside this function, we should
check if the size of this list is equal to the number of active
interfaces at the current moment (the number of active interfaces can
be checked in the last history marker). If the values differ, this
means new interfaces were created, and we should regenerate our
ordered list. The code that performs this can be seen below:

@<Generating Ordered List of interfaces@>=
if(z_list_size != last_marking -> number_of_interfaces){
  void *p;
  unsigned i, j;
  MUTEX_WAIT(&z_list_mutex);
  // Realocando
  if(z_list != NULL && permanent_free != NULL)
    permanent_free(z_list);
  z_list_size = last_marking -> number_of_interfaces;
  z_list = (struct user_interface **)
             permanent_alloc(sizeof(struct user_interface *) * z_list_size);
  // Copiando para lista:
  p = last_marking -> next;
  for(i = 0; i < z_list_size; i ++){
    if(((struct user_interface *) p) -> type == TYPE_INTERFACE)
      z_list[i] = (struct user_interface *) p;
    else if(((struct user_interface *) p) -> type == TYPE_LINK)
      z_list[i] = ((struct link *) p) -> linked_interface;
    else if(((struct user_interface *) p) -> type == TYPE_SHADER)
      i --; // Not an interface
    else if(((struct user_interface *) p) -> type == TYPE_SOUND)
      i --; // Sound interfaces are not rendered
    p = ((struct user_interface *) p) -> next;
  }
  // Ordering list (insertion sort):
  for(i = 1; i < z_list_size; i ++){
    j = i;
    while(j > 0 && z_list[j - 1] -> z > z_list[j] -> z){
      p = z_list[j];
      z_list[j] = z_list[j - 1];
      z_list[j - 1] = (struct user_interface *) p;
      j = j - 1;
    }
  }
  MUTEX_SIGNAL(&z_list_mutex);
}
@

Notice that the scenario in which the ordered list should be rebuilt
using the code above is uncommon. We run that code when rendering for
the first time in a main loop or after restoring our interface
history. The only expected scenario in which the code runs more
frequently is when the user is creating new interfaces in their
program’s main loop. In such cases, every rendering after a new
interface creation will execute the code above. However, this is
considered bad practice, so we assume that the code above will rarely
be executed, despite being placed inside the rendering
function. Typically, we already have an ordered list with all active
interfaces, and we only need to adjust the interface’s position in the
list if the interface is moved.

Once we have the ordered list of interfaces, we can simply render each
interface in the order they appear in the list. For each one, we load
the correct shader, pass the attributes, uniforms, and varyings to the
shader program, and use the OpenGL function to render the interface
vertices.

The interface is rendered when the function
\monoespaco{\_Wrender\_interface} is invoked. This function receives
the current time in microseconds as a parameter. But to know the
elapsed time between two consecutive renderings, we need to store the
previous time received by the function. We will store this previous
time in the variable below, which is initialized with zero before
receiving the first time:

@<Local Variables (interface.c)@>=
static unsigned long long previous_time = 0;
@

But we also need to initialize this variable during the
initialization. Otherwise, the variable would hold incorrect values if
the API is finalized and initialized again:

@<Initializing Interface API@>+=
previous_time = 0;
@

Below we show the function that iterates over the ordered list of
interfaces and renders each one, also updating the time variables. The
function first updates the time, then loads the interface vertices,
indicating how they are represented, and finally iterates over the
interfaces.

For each interface, it loads the shader program and passes to it each
uniform and varying variable necessary, which are stored in the
interface struct. After this, it checks the interface textures. If
there is more than one texture, this means we could have animated
textures (for example, an animated GIF).

If we indeed have an animated texture, we check the elapsed time
between renderings and the time spent in the current animation
frame. If it is time to change to the next animation frame, we update
it. Finally, we pass the correct texture to the shader.

Only after iterating over all interfaces do we store the current time
in our static global variable that remembers when the last rendering
occurred.

The implementation of the procedure described above is:


@<API Functions Definition (interface.c)@>+=
void _Wrender_interface(unsigned long long time){
  @<Generating Ordered List of interfaces@>
  {
    unsigned i, elapsed_time;
    if(previous_time != 0)
      elapsed_time = (int) (time - previous_time);
    else
      elapsed_time = 0;
    // Default framebuffer
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    // Using VBO vertices:
    glBindBuffer(GL_ARRAY_BUFFER, interface_vbo);
    // Specifying how vertices are stored in VBO:
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float),
                          (void *) 0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float),
                          (void *) (3 * sizeof(float)));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    MUTEX_WAIT(&z_list_mutex);
    for(i = 0; i < z_list_size; i ++){
      if(!(z_list[i] -> _loaded_texture) || !(z_list[i] -> visible))
        continue;
      // Animating texture
      if(z_list[i] -> animate &&
         z_list[i] -> max_repetition != 0){
        z_list[i] -> _t += elapsed_time;
        z_list[i] -> current_frame %= z_list[i] -> number_of_frames;
        while(z_list[i] -> _t >
                     z_list[i] -> frame_duration[z_list[i] -> current_frame] &&
              z_list[i] -> max_repetition != 0){
          z_list[i] -> _t -=
            z_list[i] -> frame_duration[z_list[i] -> current_frame];
          z_list[i] -> current_frame ++;
          z_list[i] -> current_frame %= z_list[i] -> number_of_frames;
          if(z_list[i] -> number_of_frames == 1 &&
             z_list[i] -> _reload_texture != NULL){
	    z_list[i] -> _reload_texture(z_list[i]); // Procedural texture
	    // Rendering procedural texture can contaminate the OpenGL state.
	    // So we need to set it again in this case:
	    glBindFramebuffer(GL_FRAMEBUFFER, 0);
	    glBindBuffer(GL_ARRAY_BUFFER, interface_vbo);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float),
                                 (void *) 0);
            glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float),
                                 (void *) (3 * sizeof(float)));
            glEnableVertexAttribArray(0);
            glEnableVertexAttribArray(1);
	    // It can be relatively time-consuming to reload a texture, and
	    // it also often requires memory allocations. Because of this, we
	    // will limit the number of invocations of this function to 1 per
	    // frame:
	    if(z_list[i] -> _t > z_list[i] -> frame_duration[0])
	      z_list[i] -> _t = z_list[i] -> frame_duration[0];
	  }
          else if(z_list[i] -> current_frame == 0 && z_list[i] -> max_repetition > 0)
	    z_list[i] -> max_repetition --;
	  if(z_list[i] -> frame_duration[z_list[i] -> current_frame] == 0)
	    break;
        }
      }
      // Choosing correct shader:
      glUseProgram(z_list[i] -> shader_program -> program);
      // Passing uniforms:
      glUniform4fv(z_list[i] -> shader_program -> uniform_foreground_color, 4,
                   z_list[i] -> foreground_color);
      glUniform4fv(z_list[i] -> shader_program -> uniform_background_color, 4,
                   z_list[i] -> background_color);
      glUniformMatrix4fv(z_list[i] -> shader_program ->
                           uniform_model_view_matrix, 1, false,
                         z_list[i] -> _transform_matrix);
      glUniform2f(z_list[i] -> shader_program -> uniform_interface_size,
                  z_list[i] -> width, z_list[i] -> height);
      glUniform2f(z_list[i] -> shader_program -> uniform_mouse_coordinate,
                  z_list[i] -> mouse_x, z_list[i] -> mouse_y);
      // O shader recebe contagem de tempo em segundos módulo 1 hora
      glUniform1f(z_list[i] -> shader_program -> uniform_time,
                  ((double) (time % 3600000000ull)) / (double) (1000000.0)); 
      glUniform1i(z_list[i] -> shader_program -> uniform_integer,
                 z_list[i] -> integer);
      // Rendering:
      if(z_list[i] -> _texture1 != NULL)
        glBindTexture(GL_TEXTURE_2D,
                      z_list[i] -> _texture1[z_list[i] -> current_frame]);
      else
        glBindTexture(GL_TEXTURE_2D, default_texture);
      glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
    }
    MUTEX_SIGNAL(&z_list_mutex);
    glBindTexture(GL_TEXTURE_2D, 0);
  }
  previous_time = time;
}
@

\secao{8. Moving, Rotating and Resizing Interfaces}

\subsecao{8.1. Moving Interfaces}

Moving an interface means updating its $(x,y,z)$ variables. In
addition to this, we also need to update the model-view matrix to
reflect the new $x$ and $y$ values, after converting them to OpenGL
coordinates. And if we are changing the $z$ coordinate, then we may
need to update the position of this interface in the ordered list of
interfaces that determines the drawing order.

All these changes must be performed after acquiring the interface
mutex, to prevent two simultaneous invocations of this function on the
same interface.

The API function that moves interfaces is
\monoespaco{\_Wmove\_interface}, and we define it as:

@<API Functions Definition (interface.c)@>+=
void _Wmove_interface(struct user_interface *i,
                      float new_x, float new_y, float new_z){
  GLfloat x, y;
  GLfloat cos_theta = cos(i -> _rotation);
  GLfloat sin_theta = sin(i -> _rotation);
  MUTEX_WAIT(&(i -> mutex));
  i -> x = i -> _x = new_x;
  i -> y = i -> _y = new_y;
#if defined(W_FORCE_LANDSCAPE)
  if(*window_height > *window_width){
     i -> _x = *window_width - new_y;
     i -> _y = new_x;
  }
#endif 
  @<Converting Coordinates and Sizes@>
  i -> _transform_matrix[12] = x +
    (i -> height / (*window_width)) * sin_theta -
    (i -> width / (*window_width)) * cos_theta;
  i -> _transform_matrix[13] = y -
    (i -> width / (*window_height)) * sin_theta -
    (i -> height / (*window_height)) * cos_theta;
  if(new_z != i -> z){ // Atualizando lista ordenada de interfaces
    unsigned j;
    i -> z = new_z;
    MUTEX_WAIT(&z_list_mutex);
    for(j = 0; j < z_list_size; j ++){
      if(z_list[j] == i){
        while(j > 0 && i -> z < z_list[j - 1] -> z){
          z_list[j] = z_list[j - 1];
          z_list[j - 1] = i;
          j --;
        }
        while(j < z_list_size - 1 && i -> z > z_list[j + 1] -> z){
          z_list[j] = z_list[j + 1];
          z_list[j + 1] = i;        
          j ++;
        }
      }
    }
    MUTEX_SIGNAL(&z_list_mutex);
  }
  MUTEX_SIGNAL(&(i -> mutex));
}
@

\subsecao{8.2. Rotating Interfaces}

Rotating an interface involves acquiring its mutex, updating the
rotation variable, and also updating its model-view matrix. The
corresponding code is shown below:

@<API Functions Definition (interface.c)@>+=
void _Wrotate_interface(struct user_interface *i, float rotation){
  GLfloat x, y;
  GLfloat cos_theta = cos(rotation);
  GLfloat sin_theta = sin(rotation);
  MUTEX_WAIT(&(i -> mutex));
  i -> rotation = i -> _rotation = rotation;
#if defined(W_FORCE_LANDSCAPE)
  if(*window_height > *window_width)
    i -> _rotation += M_PI_2;
#endif 
  @<Converting Coordinates and Sizes@>
  i -> _transform_matrix[0] = (2 * i -> width / (*window_width)) *
    cos_theta;
  i -> _transform_matrix[1] = (2 * i -> width / (*window_height)) *
    sin_theta;
  i -> _transform_matrix[4] = -(2 * i -> height / (*window_width)) *
     sin_theta;
  i -> _transform_matrix[5] = (2 * i -> height / (*window_height)) *
    cos_theta;
  i -> _transform_matrix[12] = x +
    (i -> height / (*window_width)) * sin_theta -
    (i -> width / (*window_width)) * cos_theta;
  i -> _transform_matrix[13] = y -
    (i -> width / (*window_height)) * sin_theta -
    (i -> height / (*window_height)) * cos_theta;
  MUTEX_SIGNAL(&(i -> mutex));
}
@

\subsecao{8.3. Resizing Interfaces}

Resizing interfaces, like rotating them, involves simply acquiring the
mutex, updating the associated variables, and updating the model-view
matrix.

The code to resize interfaces is:

@<API Functions Definition (interface.c)@>+=
void _Wresize_interface(struct user_interface *i,
                        float new_width, float new_height){
  GLfloat x, y;
  GLfloat cos_theta = cos(i -> _rotation);
  GLfloat sin_theta = sin(i -> _rotation);
  MUTEX_WAIT(&(i -> mutex));
  i -> width = new_width;
  i -> height = new_height;
  if(i -> _reload_texture != NULL)
    i -> _reload_texture(i); // Recreate texture if we have a vector texture
  @<Converting Coordinates and Sizes@>
  i -> _transform_matrix[0] = (2 * i -> width / (*window_width)) *
    cos_theta;
  i -> _transform_matrix[1] = (2 * i -> width / (*window_height)) *
    sin_theta;
  i -> _transform_matrix[4] = -(2 * i -> height / (*window_width)) *
     sin_theta;
  i -> _transform_matrix[5] = (2 * i -> height / (*window_height)) *
    cos_theta;
  i -> _transform_matrix[12] = x +
    (i -> height / (*window_width)) * sin_theta -
    (i -> width / (*window_width)) * cos_theta;
  i -> _transform_matrix[13] = y -
    (i -> width / (*window_height)) * sin_theta -
    (i -> height / (*window_height)) * cos_theta;
  MUTEX_SIGNAL(&(i -> mutex));
}
@

\secao{8. Interacting with Interfaces}

Given the active interfaces, we can interact with them by moving the
mouse cursor over them or clicking on them with a mouse button. To
manage these interactions, we use the function
\monoespaco{\_Winteract\_interface}, which provides information about
the mouse's behavior and automatically executes the functions
associated with interface interactions.

To make this possible, we need to keep track of the mouse button
states. This means storing not only the current state of each mouse
button but also its previous state. To do this, we will use the
following variables---one for each mouse button:

@<Local Variables (interface.c)@>=
static bool mouse_last_left_click = false, mouse_last_middle_click = false,
  mouse_last_right_click = false;
@

We initialize these variables with false during the API
initialization:

@<Initializing Interface API@>+=
mouse_last_left_click = false;
mouse_last_middle_click = false;
mouse_last_right_click = false;
@

Knowing the previous and current mouse states, we can detect not only
whether the user is clicking something, but also whether the click has
just started in the current frame or is merely continuing. Similarly,
we can tell not just whether the user is not clicking, but also
whether the button was released at some point between the previous and
current frames. This information is essential for correctly executing
the functions that handle interactions with each interface.

In a given frame, we can interact with only one interface at a time,
as we have only a single mouse cursor. But if more than one interface
occupies the same position, how do we determine which one should
respond to interaction? Fortunately, we have an ordered list of active
interfaces, sorted by their rendering order. When multiple interfaces
overlap at the cursor position, the correct one is the front-most
interface in this list.

Therefore, we iterate over the interfaces in reverse drawing order and
check which is the first one under the mouse cursor. This becomes the
currently active interface. If another interface was previously marked
as active, we remove its mark and treat it as the previously
interacted interface. If needed, and if such interfaces exist, we call
the appropriate functions: one to handle the cursor leaving the
previous interface, and another to handle the cursor hovering over or
clicking on the new current interface.

The code that performs this is:

@<API Functions Definition (interface.c)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool left_click,
                          bool middle_click, bool right_click){
  int i;
  struct user_interface *previous = NULL, *current = NULL;
  MUTEX_WAIT(&z_list_mutex);
  for(i = z_list_size - 1; i >= 0; i --){
    float x, y;
    @<Converting Mouse Coordinates to x and y@>
    z_list[i] -> mouse_x = x - z_list[i] -> x + (z_list[i] -> width / 2);
    z_list[i] -> mouse_y = y - z_list[i] -> y + (z_list[i] -> height / 2);
    if(current == NULL &&
       z_list[i] -> mouse_x  > 0 && z_list[i] -> mouse_x < z_list[i] -> width &&
       z_list[i] -> mouse_y  > 0 && z_list[i] -> mouse_y < z_list[i] -> height)
      current = z_list[i];
    else{
      if(z_list[i] -> _mouse_over){
         z_list[i] -> _mouse_over = false;
         previous = z_list[i];
       }
    }
  }
  MUTEX_SIGNAL(&z_list_mutex);
  if(previous != NULL && previous -> on_mouse_out != NULL){
    previous -> on_mouse_out(previous);
  }
  if(current != NULL){
    if(current -> _mouse_over == false){
      current -> _mouse_over = true;
      if(current -> on_mouse_over != NULL)
        current -> on_mouse_over(current);
    }
    if(left_click && !mouse_last_left_click && current -> on_mouse_left_down)
      current -> on_mouse_left_down(current);
    else if(!left_click && mouse_last_left_click && current -> on_mouse_left_up)
      current -> on_mouse_left_up(current);
    if(middle_click && !mouse_last_middle_click &&
       current -> on_mouse_middle_down)
      current -> on_mouse_middle_down(current);
    else if(!middle_click && mouse_last_middle_click &&
            current -> on_mouse_middle_up)
      current -> on_mouse_middle_up(current);
    if(right_click && !mouse_last_right_click && current -> on_mouse_right_down)
      current -> on_mouse_right_down(current);
    else if(!right_click && mouse_last_right_click &&
            current -> on_mouse_right_up)
      current -> on_mouse_right_up(current);
  }
  mouse_last_left_click = left_click;
  mouse_last_middle_click = middle_click;
  mouse_last_right_click = right_click;
}
@

This code is straightforward, but we omitted the part where we
transform the mouse coordinates into $(x,y)$ coordinates to compare
them against each interface. If the interface is not rotated, no
transformation is needed---we can use the mouse coordinates
directly. However, if the interface is rotated, the easiest way to
determine whether the mouse is over it is to ignore the interface’s
rotation and instead rotate the mouse position by the opposite angle,
using the center of the interface as the axis. After this
transformation, we can check whether the mouse is over the interface
using the usual method.

Our code to generate $(x,y)$ first checks whether the interface is
rotated. If not, no transformation is performed. Otherwise, we apply
trigonometric calculations to compute the transformed coordinate:

@<Converting Mouse Coordinates to x and y@>=
if(z_list[i] -> rotation == 0.0){
  x = mouse_x;
  y = mouse_y;
}
else{
 float cos_theta = cos(- (z_list[i] -> rotation));
 float sin_theta = sin(- (z_list[i] -> rotation));
 x = (mouse_x - z_list[i] -> x) * cos_theta -
       (mouse_y - z_list[i] -> y) * sin_theta;
 y = (mouse_x - z_list[i] -> x) * sin_theta +
       (mouse_y - z_list[i] -> y) * cos_theta;
 x +=  z_list[i] -> x;
 y +=  z_list[i] -> y;
}
@

\secao{9. Sound Interfaces}

Sound interfaces are similar to visual interfaces, but much
simpler. They have no size, position, texture, or any visual
form. They are just a long numeric sequence representing a
waveform. However, extracting such a waveform from a file requires
interpreting a specific format in which the wave is stored. As with
visual interfaces, we will not worry about how to interpret different
formats. We won’t show how to read an MP3 file, just as we didn’t show
how to read a PNG file for visual interfaces. Instead, we will
delegate to the user the responsibility of providing appropriate
functions that interpret such formats, just as is done with visual
interfaces.

If no format is passed or recognized, we will assume an empty sound,
which is represented by the integer identifying the buffer having the
value zero.

The function that interprets a file and generates a new sound is:

@<API Functions Definition (interface.c)@>+=
struct sound *_Wnew_sound(char *filename){
  struct sound *new_sound;
  void (*loading_function)(void *(*permanent_alloc)(size_t),
                           void (*permanent_free)(void *),
                           void *(*temporary_alloc)(size_t),
                           void (*temporary_free)(void *),
                           void (*before_loading_interface)(void),
                           void (*after_loading_interface)(void),
                           char *source_filename, void *target);
  new_sound = permanent_alloc(sizeof(struct sound));
  if(new_sound != NULL){
    new_sound -> type = TYPE_SOUND;
    new_sound -> next = NULL;
    new_sound -> buffer = 0;
    MUTEX_WAIT(&linked_list_mutex); // Inserindo na lista encadeada
    if(last_structure != NULL)
      ((struct user_interface *) last_structure)-> next = (void *) new_sound;
    last_structure = (void *) new_sound;
    last_marking -> number_of_interfaces ++;
    MUTEX_SIGNAL(&linked_list_mutex);
    if(filename != NULL){ // Obtém e executa função de carregamento
      char *ext;
      for(ext = filename; *ext != '\0'; ext ++);
      for(; *ext != '.' && ext != filename; ext --);
      if(*ext == '.'){
        ext ++;
        loading_function = get_loading_function(ext);
        if(loading_function != NULL)
          loading_function(permanent_alloc, permanent_free, temporary_alloc,
                           temporary_free, before_loading_interface,
                           after_loading_interface, filename, new_sound);
      }
    }
  }
  return new_sound;
}
@

The final part of the code is almost identical to that of visual
interfaces: we also store sound interfaces in the same linked list,
where they will be managed and deallocated through history markers,
requiring the activation of the necessary mutexes to handle the
list. We also rely on a user-provided function to interpret a specific
audio file format. The only difference lies in having fewer variables
to initialize beforehand.

But to be able to play audio, we need to properly initialize the
OpenAL library. The library deals with the following concepts:

1) Sound devices: different hardware pieces available on the computer
for playback. For example, headphones and speakers.

2) Listener: a unique object associated with each device that
represents an audio receiver in a virtual environment defined by
coordinates in a three-dimensional Cartesian space. It also has an
associated velocity and orientation.

3) Source: A sound source is a virtual point in a three-dimensional
Cartesian space representing a sound-emitting object. It also has an
associated velocity vector. The velocity and distance between the
source and the listener are taken into account to determine sound
intensity and distortions caused by the Doppler effect.

4) Buffer: The location where the raw representation of the sound wave
we can play is stored. Each buffer must be associated with a source.

In our case, we are not dealing with a three-dimensional scenario. So,
we will assume that sources and listener are not moving and all them
occupy the same space.

But first, let's handle the first type of object, whose complexity we
cannot avoid: the devices. We will use a pointer to always refer to
the current sound device, which we will use every time we play a
sound. And also a pointer to its corresponding audio context:

@<Local Variables (interface.c)@>+=
static ALCdevice *current_device;
static ALCcontext *context;
@

This pointer must be initialized in our initialization function. We
use a call to \monoespaco{alcOpenDevice} passing NULL as an argument
to start with the default device. The function will return NULL if no
audio device exists. Thus, we will know that if the variable
\monoespaco{default\_device} is a null pointer, then we are on a
system without sound. If we are not, then we can also initializer our
audio context:

@<Initializing Interface API@>+=
current_device = alcOpenDevice(NULL);
if(current_device != NULL){
  context = alcCreateContext(current_device, NULL);
  alcMakeContextCurrent(context);
} 
@

When we finalize our interface API, we must close the device we have
there and end its context:

@<Finalizing Interface API@>+=
if(current_device != NULL){
  alcDestroyContext(context);
  alcCloseDevice(current_device);
}
@

But how can the programmer change the default device? How can they
know which other devices exist? To help with this, we will use a
variable to store the number of devices we have and another to store
their names as string:

@<Local Variables (interface.c)@>+=
static int number_of_sound_devices;
static char **sound_device_name;
@

These variables are checked and filled during initialization. The key
to assigning their values is to call the \monoespaco{alcGetString}
function, passing \monoespaco{ALC\_DEFAULT\_DEVICE\_SPECIFIER} as an
argument, thus obtaining a string with the list of all devices. This
string follows a different convention from the usual in its
representation: it uses two consecutive null characters to signal its
end, and a single null character to serve as a separator between
different device names.

This way, we can count the number of interfaces by counting the number
of null characters in the string, stopping when we find two in a
row. If there are 1 or 0 devices, we will read 2 null characters. If there
are 2, we will read 3. Each new device adds one more null character as
a separator. So, the code below calculates the number of devices
following this logic:

@<Initializing Interface API@>+=
{
  char *c, *devices;
  int count = 0;
  c = devices = (char *) alcGetString(NULL, ALC_DEVICE_SPECIFIER);
  while(c == devices || *c != '\0' || *(c-1) != '\0'){
    if(*c == '\0')
      count ++;
    c ++;
  }
  count ++;
  if(*devices == '\0')
    number_of_sound_devices = 0;
  else
    number_of_sound_devices = count - 1;
  @<Initialization: Read Audio Device Names@>
}
@

If there is at least one audio device, we allocate the array that will
hold the list of devices and fill each of its elements with the
address where the corresponding device name is stored:

@<Initialization: Read Audio Device Names@>=
if(number_of_sound_devices > 0){
  int i = 0;
  sound_device_name = (char **) permanent_alloc(number_of_sound_devices *
                                                sizeof(char *));
  if(sound_device_name == NULL)
    number_of_sound_devices = 0;
  else{
    for(c = devices; c == devices || *c != '\0' || *(c-1) != '\0'; c ++)
      if(c == devices || *(c-1) == '\0'){
        sound_device_name[i] = c;
	i ++;
      }
  }
}
@

During finalization, it will be necessary to deallocate the list of
device names:

@<Finalizing Interface API@>+=
if(permanent_free != NULL)
  permanent_free(sound_device_name);
@

We have a default device already selected and a list of existing
devices. But which device in the existing list corresponds to the
chosen default device? Ideally, we want to store in the variable below
the number corresponding to the position of the default device in the
list of interface names:

@<Local Variables (interface.c)@>+=
static int current_device_id;
@

The documentation says that the only way to find out is by reading the
string with the default device name and comparing it to the list of
strings we have. That is what we do below:

@<Initializing Interface API@>+=
if(number_of_sound_devices > 0){
  int i;
  char *query;
  query = (char *) alcGetString(NULL, ALC_DEFAULT_DEVICE_SPECIFIER);
  for(i = 0; i < number_of_sound_devices; i ++)
    if(!strcmp(query, sound_device_name[i])){
      current_device_id = i;
      break;
    }
}
@

With this, we are already able to implement the API function that
provides this information to the user:

@<API Functions Definition (interface.c)@>+=
char **_Wget_sound_device_information(int *number_of_devices,
                                      int *current_dev){
  *number_of_devices = number_of_sound_devices;
  *current_dev = current_device_id;
  return sound_device_name;  
}
@

It's worth noting that not all OpenAL implementations support
enumerating the available devices. This enumeration feature we are
using is an extension. However, even if an implementation does not
support enumeration, it will still work with the code above. It will
simply return a single device---the default one---when we request the
list of devices.

For each device, we must also maintain a listener and sound
sources. If we do not create a listener explicitly, a default listener
will be used. Since we have no reason to modify the default listener’s
configuration, this is what we’ll rely on. Regarding sound sources, we
will declare a number of them defined by the macro
\monoespaco{Wz_SOUND\_INTERFACE\_SOURCES}. If this macro is not defined,
the default value will be 5. This corresponds to the number of
interface sounds that can play simultaneously at any given time:

@<Local Variables (interface.c)@>+=
#if !defined(W_SOUND_INTERFACE_SOURCES)
#define W_SOUND_INTERFACE_SOURCES 5
#endif
static ALuint source[W_SOUND_INTERFACE_SOURCES];
@

We initialize the sources during the initialization process with
default values. We want them to occupy the same position as the
listener (the origin), remain stationary, and play the sound only once
when requested:

@<Initializing Interface API@>+=
{
  int i;
  alGenSources(5, source);
  for(i = 0; i < W_SOUND_INTERFACE_SOURCES; i ++){
    alSourcef(source[i], AL_PITCH, 1);
    alSourcef(source[i], AL_GAIN, 1);
    alSource3f(source[i], AL_POSITION, 0, 0, 0);
    alSource3f(source[i], AL_VELOCITY, 0, 0, 0);
    alSourcei(source[i], AL_LOOPING, AL_FALSE);
  }
}
@

During finalization, we must destroy the sources:

@<Finalizing Interface API@>+=
alDeleteSources(5, source);
@

With this, we already have the necessary structures to change the
default audio device. The audio context is always associated with a
device, and the audio sources are linked to the current context. This
means that when we change the default device, we need to recreate all
these objects.

With this in mind, we can correctly implement the function that
changes the current device:

@<API Functions Definition (interface.c)@>+=
bool _Wselect_sound_device(int chosen_device){
  int i;
  if(chosen_device < 0 || chosen_device >= number_of_sound_devices)
    return false;
  // Remove current context:
  alDeleteSources(5, source);
  if(context != NULL){
    alcMakeContextCurrent(NULL);
    alcDestroyContext(context);
    alcCloseDevice(current_device);
  }
  alcCloseDevice(current_device);
  // Change device:
  current_device = alcOpenDevice(sound_device_name[chosen_device]);
  current_device_id = chosen_device;
  // Creating new context:
  if(current_device != NULL){
    context = alcCreateContext(current_device, NULL);
    alcMakeContextCurrent(context);
  }
  alGenSources(5, source);
  for(i = 0; i < W_SOUND_INTERFACE_SOURCES; i ++){
    alSourcef(source[i], AL_PITCH, 1);
    alSourcef(source[i], AL_GAIN, 1);
    alSource3f(source[i], AL_POSITION, 0, 0, 0);
    alSource3f(source[i], AL_VELOCITY, 0, 0, 0);
    alSourcei(source[i], AL_LOOPING, AL_FALSE);
  }
  return true;
}
@

And finally, we present the function that will play a sound. Remember
that a properly initialized sound structure holds a reference to an
already initialized OpenAL buffer. All we need to do is get the first
available source and play it. If no sources are available (either all
of them are already playing sounds, or the user changed their number
to zero), or if the sound has not yet been loaded, we signal that the
sound was not played by returning false. Otherwise, if we succeed, we
return true.

@<API Functions Definition (interface.c)@>+=
bool _Wplay_sound(struct sound *snd){
  int i;
  if(!(snd -> _loaded_sound))
    return false;
  for(i = 0; i < W_SOUND_INTERFACE_SOURCES; i ++){
    alSourcei(source[i], AL_BUFFER, snd -> buffer);
    if(alGetError() == AL_NO_ERROR)
      break;
  }
  if(i < W_SOUND_INTERFACE_SOURCES){
    alSourcePlay(source[i]);
    return true;
  }
  return false;
}
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}

\fim
