\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of the user
  interface used by Weaver Game Engine. The code presented here are
  intended to be used when creating buttons, text, menus and other
  user interface elements. It basically manages shaders, create
  elements that can be moved, rotated, clicked and can react to mouse
  hovering. The API presented here are intended to be flexible, the
  user can extend it and change its behavious registering new
  functions.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém a implementação da interface de usuário do
  Moto de Jogos Weaver. O código apresentado aqui é projetado para ser
  usado ao criar botões, texto, menus e outros elementos de interface
  de usuário. O código deste artigo basicamente gerencia ``shaders''
  OpenGL e cria elementos que podem ser movidos, rotacionados,
  clicados e podem reagir quando o mouse passa sobre eles. A API
  apresentada aqui é projetada para ser flexível, o usuário pode
  ampliá-la e mudar seu comportamento registrando novas funções.}

\secao{1. Introdução}

Uma interface de usuário é como um programa se comunica com o usuário
e obtém informações dele. Em um programa típico temos menus, botões,
janelas de pop-up e outros elementos de interface típico. Mas em jogos
de cmputador a intrface de usuário tende a ser muito mais simples
conveitualmente, geralmente formada por alguns menus e por elementos
de visualização que dão informações sobre o estado do jogo. POr
exemplo, um número no canto da tela indicando quantas vidas o jogador
tem.

O fato é que no caso de um jogo de computador, não podemos assumir
nada sobre a aparência dos menus, sobre o que eles vã fazer e sobre o
que é cada elemento de interface. Um jogo de estratégia poderá ter
muuitos menus quando alguém clica com o mouse em uma unidade. Um jogo
de plataforma pode ter apenas informações sobre itens equipados e
número de vidas. A aparência de tais elementos pode variar enormemente
dependendo do estilo do jogo.

A única característica universal que iremos assumir para os elementos
de interface com o usuário é que eles sempre devem aparecer sobre o
cenário do jogo, não deve ser obscurecido por objetos que fazem parte
do mundo do jogo. Tipicamente renderizaremos as interfaces de usuário
depois de termos renderizado o mundo de nosso jogo. Além disso, eles
não irão interagir com elementos do mundo do jogo. Eles não fazem
parte diretamente do mundo que o jogo simula, eles são apenas
elementos que dão informações adicionais para o jogador sobre coisas
deste mundo, que de outra forma seriam difíceis de serem expressadas.

O nosso objetivo aqui será criar uma API onde o usuário pode criar uma
nova interface de usuário invocando a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>=
struct interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float width, float height);
@
\fimcodigo

Onde o primeiro argumento é o nome de um arquivo que será aberto e
interpretado descrevendo a textura da interface (pode ser um arquivo
com uma imagem, por exemplo) e o segundo argumento é um nome de
arquivo contendo o shader. Ambos os argumentos podem ser NULL. Um
shader nulo significa que um shader padrão será usado. Um arquivo
vazio significa que nenhuma textura será preenchida mas usaremos o
shader para desenhar a interface na tela. Os demais argumentos são a
posição e tamanho inicial da interface na tela.

Podemos definir seus shaders mais facilmente se fornecermos nossa
própria biblioteca com definições de funções para o código GLSL. Para
isso, podemos passar uma string com código de funções para a função
abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_interface_shader_library(char *source);
@
\fimcodigo

Uma vez que tenhamos uma interface, poderemos movê-la com a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmove_interface(struct interface *i, float x, float y, float z);
@
\fimcodigo

Assumimos que a posição de uma interface é a coordenada em pixels de
seu centro. O eixo $x$ e $y$ representa a posição horizontal e
vertical. O eixo $z$ determina quais interfaces aparecerão na frente
se estiverem ocupando as mesmas posições no espaço.

Podemos também rotacioná-la com a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrotate_interface(struct interface *i, float rotation);
@
\fimcodigo

A função acima recebe o quanto a imagem será rotacionada em relação à
orientação padrão usando radianos como medida.

Podemos redimencionar a interface com a função abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wresize_interface(struct interface *i, float new_width, float new_height);
@
\fimcodigo

A função acima deverá respeitar limites ajustados pelo usuário, se
eles existirem. Pode-se estabelecer valores mínimos para uma interface
com o código abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_max_size_interface(struct interface *i, float max_width,
                              float max_height);
@
\fimcodigo

Um tamanho máximo de zero significa que a interface não tem um tamanho
máximo. Pode-se também ajustar um tamanho mínimo com a função abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_min_size_interface(struct interface *i, float min_width,
                              float min_height);
@
\fimcodigo

O tamanho mínimo e máximo de uma interface tem um papel mais
importante quando a nossa janela ou área de desenho é
redimencionada. Quando isso acontece, a função abaixo deve ser
chamada. Ela irá redimencionar e mover todas as interfaces para manter
a mesma proprção em relação à janela ou área de desenho. Mas ela fará
isso respeitando as restrições de tamanho máximo e mínimo estabelecida
pelas duas funções anteriores.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wupdate_size_interface(unsigned old_width, unsigned old_height,
                             unsigned new_width, unsigned new_height);
@
\fimcodigo

A função anterior redimenciona de maneira apropriada todas as
interfaces previamente criadas. Da mesma forma, a função abaixo
renderiza na tela todas as interfaces disponíveis, sem precisarmos
manualmente indicá-las:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrender_interface(void);
@
\fimcodigo

Mas renderizar todas as interfaces criadas pode não ser o desejado
pelo usuário. Pode ser que queiramos renderizar somente as últimas
interfaces criadas à partir de um ponto da história.  Para isso, a
função abaixo cria uma marcação no nosso histórico de criação de
interfaces. E toda vez que pedimos para renderizar, somente as
interfaces criadas depois da marcação serão rendrizadas:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmark_history_interface(void);
@
\fimcodigo

Mas e se queremos renderizar somente algumas das interfaces criadas
antes da marcação? Neste caso, podemos simplismente criar uma nova
interface que na verdade é uma ligação para uma anterior:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
struct interface *_Wlink_interface(struct interface *i);
@
\fimcodigo

Já para interagir com todas as interfaces criadas no passado até a
última marcação, usamos a função abaixo. Ela irá executar as ações
programadas quando um usuário passa o mouse sobre uma interface,
retira o mouse sobre uma interface ou clica nela:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool moving, bool left_click,
                          bool middle_click, bool right_click);
@
\fimcodigo


Mas como apagar iterfaces uma vez que não precisamos mais delas? Para
isso fornecemos a função abaixo que apaga todas as interfaces criadas
anteriormene até a última marcação na história. Ela também apaga a
última marcação existente, voltando o estado de nossa biblioteca até
como eraimediatamente antes de tal marcação ser criada. As interfaces
qu existirem antes de tal marcação, se existirem, serão novamente
renderizadas.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrestore_history_interface(void);
@
\fimcodigo

Tudo isso vai requerer que gerenciemos nosso histórico de interfaces,
suas marcações e seus shaders. E isso vai requerer que aloquemos e
desaloquemos memória. Há dois tipos de alocações que podemos fazer:
coisas permanentes que ficarão alocadas por possivelmente um bom tempo
e coisas temporárias que serão rapidamente desalocadas. Vamos então
armazenar a função de alocação e desalocação para estes dois casos:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@
\fimcodigo

Por padrão, usaremos simplesmente a função de alocação e desalocação
da biblioteca padrão. Mas o usuário pode personalizar cada uma destas
funções. Além delas, vamos também estabelecer funções personalizáveis
que serão executadas imediatamente antes e depois que formos carregar
uma nova interface. Inicialmente tais funções serão nulas, mas elas
podem ser depois ajustadas pelo usuário:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static void *(*before_loading_interface)(void) = NULL;
static void *(*after_loading_interface)(void) = NULL;
@
\fimcodigo

A ideia é que todas as funções persnalizáveis serão definidas durante
a inicialização da nossa API:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
#include <stdlib.h> // Define tipo 'size_t'
void _Winit_interface(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void *(*before_loading_interface)(void),
                      void *(*after_loading_interface)(void),
                      ...);
@
\fimcodigo


É possível inicializar as funções de desalocação como
\monoespaco{NULL}. Isso significa que nós não iremos desalocar o que
foi alocado. Isso pode ser útil caso seu gerenciador de memória
gerencie de alguma forma a coleta de lixo e não quer ter interferência
no processo.

A função acima também aceita receber um número variável de argumentos
depois das seis funções iniciais. Esses argumentos adicionais serão
uma lista terminada em NULL de uma string seguida de uma função
geradora de interfaces. A string representa uma extensão (por exemplo
``gif'', ``jpg'' ou outras) e a função que a sucede recebe como
argumento um nome de arquivo, as funções de alocação e desalocação e
um ponteiro para a interface que deve ser atualizada e preenchida de
acordo com o conteúdo do arquivo. Espera-se que a função consiga abrir
e interpretar o arquivo e gerar uma nova interface à partir dele.
Desta forma, deixamos para o usuário a responsabilidade de fornecer as
funções que criam interfaces à partir de arquivos de diferentes
formatos.

Como apresentamos uma função de inicialização, vamos precisar também
da função de finalização:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wfinish_interface(void);
@
\fimcodigo

E isso termina a nossa descrição de todas as funções que suportaremos.

\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{interface.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{interface.h}:

\iniciocodigo
@(src/interface.h@>=
#ifndef __WEAVER_INTERFACE
#define __WEAVER_INTERFACE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
#if !defined(_WIN32)
#include <sys/param.h> // Necessário no BSD, mas causa problema no Windows
#endif
@<Inclur Cabeçalhos Gerais (interface.h)@>
@<Macros Gerais (interface.h)@>
@<Declaração de Função (interface.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (interface.h)'', o mesmo nome apresentado no trecho de
código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{interface.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/interface.c@>=
#include "interface.h"
@<Cabeçalhos Locais (interface.c)@>
@<Macros Locais (interface.c)@>
@<Estrutura de Dados Locais (interface.c)@>
@<Variáveis Locais (interface.c)@>
@<Funções Auxiliares Locais (interface.c)@>
@<Definição de Funções da API (interface.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\subsecao{1.2. Suportando Múltiplas Threads}

A maior parte do código a ser definido neste documento é portável. O
único requisito assumido é que um contexto OpenGL está ativo e
funcionando. Contudo, há uma parte não-portável que deve ser definida
dependendo do sistema em que estamos: o suporte a mutex.

Um mutex é uma estrutura de dados abstrata usada para controlar acesso
de múltiplos processos a um recurso em comum. Eles serão tratados de
forma diferente dependendo do sistema operacional e ambiente. Devido à
seu caráter não-portável, eles serão introduzidos aqui, separados do
restante do código.

No Linux e BSD, o Mutex é definido pela biblioteca
\monoespaco{pthread} e segue a nomenclatura típica dela. No Windows um
Mutex é chamado de ``seção critica''. No Web Assembly não usaremos
Mutex, pois o cóigo não usará múltiplas threads.

\iniciocodigo
@<Macros Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#define _MUTEX_DECLARATION(mutex) pthread_mutex_t mutex
#elif defined(_WIN32)
#define _MUTEX_DECLARATION(mutex) CRITICAL_SECTION mutex
#elif defined(__EMSCRIPTEN__)
#define _MUTEX_DECLARATION(mutex)
#endif
@
\fimcodigo

Isso significa que no Linus e BSD nós precisamos inserir o cabeçalho
da biblioteca \monoespaco{pthread}. No Windows, basta inserir o
cabeçalho padrão do windows.

\iniciocodigo
@<Inclur Cabeçalhos Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#include <pthread.h>
#elif defined(_WIN32)
#include <windows.h>
#endif
@
\fimcodigo

No nosso código vamos precisar inicializar cada Mutex que
declararmos. Para isso, usaremos a seguinte macro:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_INIT(mutex) pthread_mutex_init(mutex, NULL);
#elif defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@
\fimcodigo

Para finalizar um Mutex quando não precisarmos mais, usamos a seguinte
macro:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(mutex);
#elif defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@
\fimcodigo

Tendo um Mutex, há duas operações que podemos fazer com ele. A
primeira é requerer o uso do Mutex. Neste momento, se algum outro
processo está usando ele, iremos esperar até que o Mutex esteja livre
novamente:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(mutex);
#elif defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@
\fimcodigo

E finalmente, depois de deixarmos de usar o recurso guardado pelo
Mutex, podemos liberar ele com o código abaixo:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(mutex);
#elif defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@
\fimcodigo

\secao{2. Estruturas de Dados}

Nesta seção descreveremos as três principais estruturas de dados que
gerenciaremos nesta API: as interfaces de usuário, as ligações para
interfaces já criadas e as marcações de tempo.

\subsecao{2.1. A Estrutura da Interface}

A principal estrutura deste documento será a estrutura que armazena
informações sobre a interface de usuário. A descrição dela é:

\iniciocodigo
@<Estrutura de Dados (interface.h)@>
struct interface {
  int type;
  void *next; // Ponteiro de lista encadeada
  float x, y, z;
  float rotation;
  GLfloat _transform_matrix[16];
  float height, width;
  floaf background_color[4], foreground_color[4];
  int integer;
  bool visible;
  GLuint _shader;
  _MUTEX_DECLARATION(interface_mutex);
  /* Atributos abaixo devem ser preenchidos por função de carregamento: */
  GLuint *_texture;
  bool _loaded_texture;
  bool animate;
  unsigned number_of_frames;
  unsigned current_frame;
  unsigned *frame_duration;
  unsigned long _t;
  int max_repetition;
};
\fimcodigo
@

Vamos agora descrever o que significa cada elemento desta estrutura.

O primeiro atributo é o tipo. Nós vamos querer armazenar as nossas
interfaces em uma lista encadeada (e por isso abaixo do tipo já temos
um ponteiro para montar a lista encadeada). Mas essa lista não
necessariamente armazenará interfaces como a acima. Nós podemos
armazenar na lista encadeada outras coisas, como marcações de tempo ou
então ligações para interfaces que já foram criadas antes. Nós
saberemos o quê exatamente tem em cada posição da lista encadeada
através do valor encontrado no tipo. O tipo pode então ser de três
tipos:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#define TYPE_INTERFACE 1 // Uma interface como a acima
#define TYPE_LINK      2 // Ligação para interface anterior
#define TYPE_MARKING   3 // Marcação no histórico de interfaces criadas
@
\fimcodigo

Toda vez então que o valor do primeiro atributo for 1, isso significa
que estamos diante de uma interface completa como a descrita acima.

Depois do tipo e so ponteiro, armazenamos as informações sobre posição
e tamanho da interface. Temos a sua posição em pixels (eixo $x$ e
$y$), seu ``índice-z'' (eixo $z$) que determina a ordem em que as
interfaces serão desenhadas e quais aparecerão na frente das outras, a
rotação (em radianos) da interface e a altura e largura (em
pixels). Todos estes valores podem ser lidos pelo usuário, mas não
devem ser modificados diretamente sem usar as funções adequadas para
isso e que srão definidas nas próximas seções. Isso porque para
corretamente mudar a posição, tamanho e rotação da interface,
precisamos atualizar a sua matriz de transfrmação (logo abaixo), que é
como o OpenG e nossos shaders realmente interpretam tais
informações. E com relação ao eixo $z$, se atualizamos ele, também
temos que atualizar uma outra lista a ser definida que controla a
ordem em que as interfaces são desenhadas na tela.

O atributo de cor de frente e de fundo representa cores no formato
RGBA onde cada valor individua é entre 0 e 1. Basicamente tais cores
serão sempre passadas para o shader de renderização. Mas não
necessariamente o shader irá usar tal informação.

Da mesma forma, o atributo inteiro que vem logo em seguida também é um
valor inteiro a ser passado para o shader. Não necessariamente ele
será usado, isso irá depender do shader.

O próximo atributo indica se a interface está visível ou não. Se não
estiver, ela não será renderizada.

O shader compilado a ser usado pela nossa interface aparece em
seguida.

E por fim, é inserida uma declaração de um mutex para que múltiplos
processos possam maniplar simultaneamente nossa interface.

Os atributos que vem à seguir desta parte inicialmente sempre começam
como sendo 0, falso ou nulo. É de responsabilidade da função de
carregamento preencher tais valores enquanto executa. A função de
carregamento é aquela que é responsável por ler um arquivo de
determinada extensão e gerar corretamente a textura da
interface.Funções de carregamento são informadas na inicialização
desta API.

Primeiro temos um ponteiro para a textura OpenGL que é passada para o
shader. Pode não ter somente uma textura, mas várias. Quando por
exemplo temos uma interface obtida através de um GIF animado, por
exemplo. Cada frame de animação será uma textura diferente.

Caso exista mais de uma textura, a próxima variável booleana determina
se a interface deve ser animada ou não. A variável pode ser modificada
à vontade durante a execução do programa para fazer com que a animação
pause ou continue.

Os dois próximos atributos representam o número total de frames da
animação (será sempre 1 quando não for uma interface animada) e qual o
frame atual em que estamos (o primeiro frame é o 0).

Em seguida encontramos um ponteiro que apontará para um vetor alocado
que conterá a duração de cada frame em unidades de tempo. Se a
interface possuir somente um ou nenhum frame, este ponteiro poderá
estar apontando para NULL.

A variável \monoespaco{\_t} será usada para realizar a contagem de
tempo internamente no caso de termos uma interface animada. Deve
iniciar como zero quando a interface é inicializada e sua textura
termina de ser carregada. Depois seguiremos incrementando o contador
automaticamente para assim sabermos quando o frame atual precisa ser
modificado ou não, a depender da duração de cada frame.

Por fim, o último atributo é, para o caso de termos uma interface
animada, quantas vezes devemos repetir até o final sua animação. O
valor de 0 significa que ela deverá ser repetida para sempre. Um valor
positivo coloca u limite no número de repetições. Quando repetirmos a
animação pela última vez permitida, ela ficará estacionada no último
frame sem voltar novamente para o primeiro.

\subsecao{2.2. Marcações no Histórico}

Como mencionado na Introdução, a lógica de quais interfaces estarão
acessíveis em um dado momento terá relação com as marcações feitas no
nosso histórico de interfaces. Todas as interfaces criadas após a
última marcação estão acessíveis, mas aquelas que forem mais antigas
que isso não poderão ser acessadas. Elas não serão renedeerizadas e
nem pode-se interagir com elas. Podem ser criadas várias marcações. E
a marcação mais recente existente pode ser destruída, o que destrói
as interfaces criadas depois dela.

Para que isso seja possível, cada marcação precisa memorizar qual era
a marcação anterior. Desta forma, quando apagamos uma marcação,
podemos substituir a marcação memorizada colocando-a no logar daquela
que foi removida. De fato, essa é a única coisa que precisamos
armazenar em uma marcação além dos dados típicos necessários para a
lista encadeada:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct marking {
  int type;
  void *next; // Ponteiro de lista encadeada
  struct marking *previous_marking;
};
@
\fimcodigo

Note que declaramos essa estrutura de dados internamente no arquivo
\monoespaco{interface.c}. Isso porque essa é uma estrutura que será
útil somente internamente à nossa API. Não haverá motivos para que o
usuário da API precise obter uma marcação destas. Ele irá interagir
com a existência delas somente por meio das funções
\monoespaco{\_Wmark\_history\_interface} e
\monoespaco{\_Wrestore\_history\_interface} descritas na Introdução.

\subsecao{2.3. Ligações para Outras Interfaces}

Caso uma interface esteja inacessível por ser mais antiga que a última
marcação, é possível criar uma ligação para ela com a função
\monoespaco{\_Wlink\_interface}. A ligação para a interface antiga
conta como se fosse uma nova interfae recém-criada e desta forma a
interface antiga volta a estar acessível. Criar uma nova ligação
significa criar e colocar na lista encadeada a seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct link {
  int type;
  void *next; // Ponteiro de lista encadeada
  struct interface *linked_interface;
};
@
\fimcodigo

Além das informações necessárias para a lista encadeada como o tipo
que identifica a estrutura e o ponteiro que apontará para o elemento
da próxima posiçao, a única informação que precisamos armazenar nesta
estrutura é um ponteiro para a interface apontada.

\secao{3. Inicialização e Finalização da API}

O objetivo da inicialização desta API é ajustar todas as funções
personalizadas que serão usadas. Já a finalização desaloca as
estruturas alocadas necessárias para armazenar algumas destas funções
e também ajusta tais funções para valores padrão.

\subsecao{3.1. Inicialização}

Aqui nosso objetivo é ajustar as seis funções personalizáveis
discutidas na Introdução e também receber uma lista de tamanho
variável de funções que irão interpretar arquivos com uma dada
extensão.

Para armazenar cada uma destas funções que vai na lista de tamanho
variável, precisamos da seguinte estrutura:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct file_function {
  char *extension;
  void (*load_texture)(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void *(*before_loading_interface)(void),
                      void *(*after_loading_interface)(void),
                      char *source_filename, struct interface *target);
};
static unsigned number_of_file_functions_in_the_list = 0;
static struct file_function *list_of_file_functions = NULL;
@
\fimcodigo

A estrutura basicamente é um par formado por uma função que extrai
texturas de um arquivo (e é informada sobre todas as funções
personalizadas que devem ser usadas) e por uma extensão de arquivo que
ela interpreta. Depois de definir a estrutura, criamos um ponteiro
para ela que irá conter uma lista de funções deste tipo conhecidas. O
ponteiro começa como uma lista vazia.

Podemos agora definir a função de inicialização. O que esta função
fará será preencher as seis funções personalizáveis básicas, contar
quantas outras funções temos que irão interpretar arquivos, alocar o
espaço necessário em nossa lista acima (usando as funções de alocação
informadas) e preencher a lista recém-alocada:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>=
void _Winit_interface(void *(*new_permanent_alloc)(size_t),
                      void (*new_permanent_free)(void *),
                      void *(*new_temporary_alloc)(size_t),
                      void (*new_temporary_free)(void *),
                      void *(*new_before_loading_interface)(void),
                      void *(*new_after_loading_interface)(void), ...){
  if(new_permanent_alloc != NULL) /* Parte 1: Preencher as 6 Funções */
    permanent_alloc = new_permanent_alloc;
  if(new_temporary_alloc != NULL)
    temporary_alloc = new_temporary_alloc;
  permanent_free = new_permanent_free;
  temporary_free = new_temporary_free;
  before_loading_interface = new_before_loading_interface;
  after_loading_interface = new_after_loading_interface;
  {
    int count = -1, i; /* Parte 2: Contar quantas mais funções existem */
    va_list args;
    char *ext;
    void (*func)(void *(*permanent_alloc)(size_t),
                 void (*permanent_free)(void *), void *(*temporary_alloc)(size_t),
                 void (*temporary_free)(void *),
                 void *(*before_loading_interface)(void),
                 void *(*after_loading_interface)(void),
                 char *source_filename, struct interface *target);
    va_start(args, new_after_loading_interface);
    do{
      count ++;
      ext = va_arg(args, char *);
      func = va_arg(args, void (*)(void *(*)(size_t), void (*)(void *),
                                   void *(*)(size_t), void (*)(void *),
                                   void *(*)(void), void *(*)(void),
                                   char *, struct interface *)); 
    } while(ext != NULL);
    number_of_file_functions_in_the_list = count;
    list_of_file_functions = (struct file_function *)
                               permanent_alloc(sizeof(struct file_function) * 
                                               count); // Parte 3: Alocar o resto
    va_start(args, new_after_loading_interface);
    for(i = 0; i < count; i ++){
      list_of_file_functions[i].extension = va_arg(args, char *);
      list_of_file_functions[i].load_texture =
             va_arg(args, void (*)(void *(*)(size_t), void (*)(void *),
                                   void *(*)(size_t), void (*)(void *),
                                   void *(*)(void), void *(*)(void),
                                   char *, struct interface *));
    }
  }
}
@
\fimcodigo

A função acima ficou verbosa graças ao fato de termos um número
variável de argumentos contendo ponteiros para funções com mais
argumentos. Infelizmente C se torna uma linguagem verbosa nestes
casos. O que infelizmente encobre o quão simples foi o que fizemos na
inicialização acima.

O uso de alguns recursos como o acesso aos argumentos por meio da
\monoespaco{va\_list} requer a inclusão do cabeçalho abaixo:

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>=
#include <stdarg.h>
@
\fimcodigo

\subsecao{3.2. Finalização}

A função complementar à nossa inicialização é a função de
finalização. Se na inicialização terminamos alocando memória para
armazenar as funções que interpretam arquivos, na finaliação
terminaremos desalocando essa mesma memória. Se na inicialização
começamos ajustanto as seis funções personalizadas básicas, na
finalização terminaremos retornando tais funções para seus valores
padrão.

\iniciocodigo
@<Definição de Funções da API (interface.c)@>+=
void _Wfinish_interface(void){
  @<Finalização da API de Interface@>
  permanent_free(list_of_file_functions);
  number_of_file_functions_in_the_list = 0;
  permanent_alloc = malloc;
  temporary_alloc = malloc;
  permanent_free = free;
  temporary_free = free;
  before_loading_interface = NULL;
  after_loading_interface = NULL;
}
@
\fimcodigo

Note que deixamos um espaço acima em vermelho para código adicional
que precisarmos colocar na finalização à medida que a API for ficando
mais complexa ao definirmos as outras funções nas seções seguintes.

E isso desfaz tudo o que foi feito na inicialização. É possível
inicializar e finalizar a API várias vezes sem que isso cause qualquer
problema.

\secao{4. Shaders}

Uma das coisas que precisaremos definir é o shader padrão a ser usado
caso o usuário não forneça nenhum personalizado. Isso nos dá uma ótima
oportunidade para apresentar os requisitos para os shaders suportados
por esta API e como esperaremos que um shader estejas organizado para
que ele seja suportado.

A primeira informação sobre o formato de um shader é qual a linguagem
usada para defini-lo. Usaremos a linguagem GLSL, mas existem várias
versões diferentes para ela. É a primeira linha de todo código GLSL
que define a versão da linguagem. Mas não iremos exigir que o usuário
preencha esta informação, nós faremos isso automaticamente.

Para escolher a versão da linguagem GLSL usada em todos os shaders,
iremos consultar se existe uma macro definida com o nome
\monoespaco{W\_GLSL\_VERSION}. Essa macro será usada para preencher a
primeira linha de todo arquivo GLSL. Caso ela não tenha sido definida
e fornecida pelo usuário, então iremos defini-la vom o valor padrão
``\monoespaco{\#version 100\\n}''. Este valor padrão significa que o
shader usará a linguagem de shader OpenGL ES v1.00. Faremos esse
ajuste de macros bem no início de nosso arquivo com a definição das
funções:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if !defined(W_GLSL_VERSION)
#define W_GLSL_VERSION "#version 100\n"
#endif
@
\fimcodigo

Há ao menos dois tipos de shaders que precisaremos definir para cada
uma das interfaces diferentes. O primeiro é o shader de vértice, que
irá ser processado para cada vértice de nossa interface. O outro é o
shader de fragmento que processará cada píxel individual. Mas como
indicamos na Inrodução, quando passamos um shader para uma interface,
passamos um único arquivo para ela ao invés de dois. Como poderemos
representar dois shaders diferentes por meio de um só arquivo?

Isso é graças ao fato de que a linguagem de shader GLSL suporta macros
condicionais de pré-processamento, assim como em C. Desta forma,
podemos definir macros diferentes se estamos compilando um shader de
vértice ou se estamos compilando um shader de fragmento. Isso será
feito definindo em cada um dos casos as seguintes macros:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static char vertex_shader_macro[] = "#define VERTER_SHADER\n";
static char fragment_shader_macro[] = "#define FRAGMENT_SHADER\n";
@
\fimcodigo

No código-fonte do shader, poderemos então verificar qual das duas
macros acima estará definida. Dependendo do caso, simplesmente
compilaremos código diferente, da mesma forma como podemos compilar
código diferente em um mesmo arquivo para Linux ou Windows em um mesmo
arquivo com código C.

A próxima coisa que será de nosso interesse será inserir bibliotecas
GLSL. O usuário poderá definir funções adicionais para facilitar o
código GLSL de seus shaders. As bibliotecas ficarão armazenadas na
seguinte variável que iniciará como sendo uma string vazia:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static char *shader_library = "";
@
\fimcodigo

A variável será modificada por meio da função que vimos na Introdução
para incrementar o GLSL com novas funções. Tal função é extremamente
simples e somente irá realizar uma atribuição:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>+=
void _Wset_interface_shader_library(char *source){
  shader_library = source;
}
@
\fimcodigo

Mas não poderemos nos esquecer que na função de finalização
precisaremos desfazer esta mudança. Do contrário, a API pode ser
finalizada e inicializada novamente de modo que a segunda
inicialização fique com as mesmas definições de função feitas na
primeira:

\iniciocodigo
@<Finalização da API de Interface@>=
shader_library = "";
@
\fimcodigo

Agora vejamos como compilar um shader completo por meio
disso. Primeiro vamos inserir os cabeçalhos OpenGL. Por padrão
assumiremos o Open GL ES 2.0. Mas em ambientes como o Windows onde ele
não necessariamente estará disponível, podemos usar a versão OpenGL
que existir, desde que suporte shaders. Dependendo do caso, o usuário
terá que incluir cabeçalhos adicionais por meio de flags de
compilação. Também vamos pedir a biblioteca de entrada e saída para
podermos imprimir mensagens de erro caso hajam erros no código do
shader.

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>+=
#if defined(__linux__) || defined(BSD)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#endif
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
#include <stdio.h>
@
\fimcodigo

Uma vez que tenhamos o cabeçalho adequado, vamos definir a função, que
dado um código-fonte de um shader OpenGL, a compila para um programa
de shader completo. Compilar um shader significa criar no OpenGL os
dois tipos de shaders (vértice e fragmento), compilar ambos, e ligá-os
em um único programa.

\iniciocodigo
@<Funções Auxiliares Locais (interface.c)@>=
@<Funções para Checar Erros de Compilação@>
static GLuint new_shader(const char *source_code){
  GLuint vertex_shader, fragment_shader, program;
  const char *list_of_source_code[4];
  vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
  list_of_source_code[0] = W_GLSL_VERSION;
  list_of_source_code[1] = vertex_shader_macro;
  list_of_source_code[2] = shader_library;
  list_of_source_code[3] = source_code;
  glShaderSource(vertex_shader, 4, list_of_source_code, NULL);
  list_of_source_code[1] = fragment_shader_macro;
  glShaderSource(fragment_shader, 4, list_of_source_code, NULL);
  glCompileShader(vertex_shader);
  if(check_compiling_error(vertex_shader))
    return 0;
  glCompileShader(fragment_shader);
  if(check_compiling_error(fragment_shader))
    return 0;
  program = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);
  if(check_linking_error(program))
    return 0;
  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);
  return program;
}
@
\fimcodigo

A parte que não é mostrada acima é como fazemos a verificação de que
um shader foi compilado com sucesso. Para isso usamos a função
abaixo. Ela funciona para os dois tipos de shader. E consiste em
consultar se ocorreu um erro de compilação. Em caso afirmativo, ela lê
dos logs do OpenGL o que aconteceu de errado e imprime. Note que
usamos as funções temporárias de alocação e desalocação para termos
espaço para a mensagem de erro. E a função retorna se achou ou não um
erro.

\iniciocodigo
@<Funções para Checar Erros de Compilação@>=
static bool check_compiling_error(GLuint shader){
  GLint status;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    int info_log_length;
    char *error_msg;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetShaderInfoLog(shader, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
  return false;
}
@
\fimcodigo

Checar se houve um erro quando ligamos os dois shaders funciona de
maneira semehante. Entretanto, podemos fazer ainda melhor. Podemos
tentar validar o shader simulando o seu uso e assim detectar erros
adicionais. Contudo, como isso é uma operação demorada e cara, faremos
isso só se a macro \monoespaco{W\_DEBUG\_INTERFACE} esteja
definida. Neste caso, assumiremos estar em modo de depuração:

\iniciocodigo
@<Funções para Checar Erros de Compilação@>+=
static bool check_linking_error(GLuint program){
  GLint status;
  GLsizei info_log_length;
  char *error_msg;
  glGetProgramiv(program, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#if defined(W_DEBUG_INTERFACE)
  glValidateProgram(program);
  glGetProgramiv(program, GL_VALIDATE_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_message = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#endif
  return false;  
}
@
\fimcodigo

E isso termina a descrição de como compilamos um novo shader e
imprimimos erros caso hajam problemas no código-fonte.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}


\fim
