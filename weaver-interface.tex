\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of the user
  interface used by Weaver Game Engine. The code presented here are
  intended to be used when creating buttons, text, menus and other
  user interface elements. It basically manages shaders, create
  elements that can be moved, rotated, clicked and can react to mouse
  hovering. The API presented here are intended to be flexible, the
  user can extend it and change its behavious registering new
  functions.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém a implementação da interface de usuário do
  Moto de Jogos Weaver. O código apresentado aqui é projetado para ser
  usado ao criar botões, texto, menus e outros elementos de interface
  de usuário. O código deste artigo basicamente gerencia ``shaders''
  OpenGL e cria elementos que podem ser movidos, rotacionados,
  clicados e podem reagir quando o mouse passa sobre eles. A API
  apresentada aqui é projetada para ser flexível, o usuário pode
  ampliá-la e mudar seu comportamento registrando novas funções.}

\secao{1. Introdução}

Uma interface de usuário é como um programa se comunica com o usuário
e obtém informações dele. Em um programa típico temos menus, botões,
janelas de pop-up e outros elementos de interface típico. Mas em jogos
de cmputador a intrface de usuário tende a ser muito mais simples
conveitualmente, geralmente formada por alguns menus e por elementos
de visualização que dão informações sobre o estado do jogo. POr
exemplo, um número no canto da tela indicando quantas vidas o jogador
tem.

O fato é que no caso de um jogo de computador, não podemos assumir
nada sobre a aparência dos menus, sobre o que eles vã fazer e sobre o
que é cada elemento de interface. Um jogo de estratégia poderá ter
muuitos menus quando alguém clica com o mouse em uma unidade. Um jogo
de plataforma pode ter apenas informações sobre itens equipados e
número de vidas. A aparência de tais elementos pode variar enormemente
dependendo do estilo do jogo.

A única característica universal que iremos assumir para os elementos
de interface com o usuário é que eles sempre devem aparecer sobre o
cenário do jogo, não deve ser obscurecido por objetos que fazem parte
do mundo do jogo. Tipicamente renderizaremos as interfaces de usuário
depois de termos renderizado o mundo de nosso jogo. Além disso, eles
não irão interagir com elementos do mundo do jogo. Eles não fazem
parte diretamente do mundo que o jogo simula, eles são apenas
elementos que dão informações adicionais para o jogador sobre coisas
deste mundo, que de outra forma seriam difíceis de serem expressadas.

O nosso objetivo aqui será criar uma API onde o usuário pode criar uma
nova interface de usuário invocando a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>=
struct interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float width, float height);
@
\fimcodigo

Onde o primeiro argumento é o nome de um arquivo que será aberto e
interpretado descrevendo a textura da interface (pode ser um arquivo
com uma imagem, por exemplo) e o segundo argumento é um nome de
arquivo contendo o shader. Ambos os argumentos podem ser NULL. Um
shader nulo significa que um shader padrão será usado. Um arquivo
vazio significa que nenhuma textura será preenchida mas usaremos o
shader para desenhar a interface na tela. Os demais argumentos são a
posição e tamanho inicial da interface na tela.

Uma vez que tenhamos uma interface, poderemos movê-la com a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmove_interface(struct interface *i, float x, float y);
@
\fimcodigo

Assumimos que a posição de uma interface é a coordenada em pixels de
seu centro.

Podemos também rotacioná-la com a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrotate_interface(struct interface *i, float rotation);
@
\fimcodigo

A função acima recebe o quanto a imagem será rotacionada em relação à
orientação padrão usando radianos como medida.

Podemos redimencionar a interface com a função abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wresize_interface(struct interface *i, float new_width, float new_height);
@
\fimcodigo

A função acima deverá respeitar limites ajustados pelo usuário, se
eles existirem. Pode-se estabelecer valores mínimos para uma interface
com o código abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_max_size_interface(struct interface *i, float max_width,
                              float max_height);
@
\fimcodigo

Um tamanho máximo de zero significa que a interface não tem um tamanho
máximo. Pode-se também ajustar um tamanho mínimo com a função abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_min_size_interface(struct interface *i, float min_width,
                              float min_height);
@
\fimcodigo

O tamanho mínimo e máximo de uma interface tem um papel mais
importante quando a nossa janela ou área de desenho é
redimencionada. Quando isso acontece, a função abaixo deve ser
chamada. Ela irá redimencionar e mover todas as interfaces para manter
a mesma proprção em relação à janela ou área de desenho. Mas ela fará
isso respeitando as restrições de tamanho máximo e mínimo estabelecida
pelas duas funções anteriores.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wupdate_size_interface(unsigned old_width, unsigned old_height,
                             unsigned new_width, unsigned new_height);
@
\fimcodigo

A função anterior redimenciona de maneira apropriada todas as
interfaces previamente criadas. Da mesma forma, a função abaixo
renderiza na tela todas as interfaces disponíveis, sem precisarmos
manualmente indicá-las:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrender_interface(void);
@
\fimcodigo

Mas renderizar todas as interfaces criadas pode não ser o desejado
pelo usuário. Pode ser que queiramos renderizar somente as últimas
interfaces criadas à partir de um ponto da história.  Para isso, a
função abaixo cria uma marcação no nosso histórico de criação de
interfaces. E toda vez que pedimos para renderizar, somente as
interfaces criadas depois da marcação serão rendrizadas:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmark_history_interface(void);
@
\fimcodigo

Mas e se queremos renderizar somente algumas das interfaces criadas
antes da marcação? Neste caso, podemos simplismente criar uma nova
interface que na verdade é uma ligação para uma anterior:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
struct interface *_Wlink_interface(struct interface *i);
@
\fimcodigo

Já para interagir com todas as interfaces criadas no passado até a
última marcação, usamos a função abaixo. Ela irá executar as ações
programadas quando um usuário passa o mouse sobre uma interface,
retira o mouse sobre uma interface ou clica nela:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool moving, bool left_click,
                          bool middle_click, bool right_click);
@
\fimcodigo


Mas como apagar iterfaces uma vez que não precisamos mais delas? Para
isso fornecemos a função abaixo que apaga todas as interfaces criadas
anteriormene até a última marcação na história. Ela também apaga a
última marcação existente, voltando o estado de nossa biblioteca até
como eraimediatamente antes de tal marcação ser criada. As interfaces
qu existirem antes de tal marcação, se existirem, serão novamente
renderizadas.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrestore_history_interface(void);
@
\fimcodigo

Tudo isso vai requerer que gerenciemos nosso histórico de interfaces,
suas marcações e seus shaders. E isso vai requerer que aloquemos e
desaloquemos memória. Há dois tipos de alocações que podemos fazer:
coisas permanentes que ficarão alocadas por possivelmente um bom tempo
e coisas temporárias que serão rapidamente desalocadas. Vamos então
armazenar a função de alocação e desalocação para estes dois casos:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@
\fimcodigo

Por padrão, usaremos simplesmente a função de alocação e desalocação
da biblioteca padrão. Mas o usuário pode personalizar cada uma destas
funções quando invoca a inicialização de nossa biblioteca:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
#include <stdlib.h> // Define tipo 'size_t'
void _Winit_interface(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *), ...);
@
\fimcodigo


É possível inicializar as funções de desalocação como
\monoespaco{NULL}. Isso significa que nós não iremos desalocar o que
foi alocado. Isso pode ser útil caso seu gerenciador de memória
gerencie de alguma forma a coleta de lixo e não quer ter interferência
no processo.

A função acima também aceita receber um número variável de argumentos
depois das quatro funções de alocação e desalocação. Esses argumentos
adicionais serão uma lista terminada em NULL de uma string seguida de
uma função geradora de interfaces. A string representa uma extensão
(por exemplo ``gif'', ``jpg'' ou outras) e a função que a sucede
recebe como argumento um nome de arquivo e as funções de alocação e
desalocação. Espera-se que a função consiga abrir e interpretar o
arquivo e gerar uma nova interface à partir dele. Se não conseguir,
retorna \monoespaco{NULL}. Desta forma, deixamos para o usuário a
responsabilidade de fornecer as funções que criam interfaces à partir
de arquivos de diferentes formatos.

Como apresentamos uma função de inicialização, vamos precisar também
da função de finalização:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wfinish_interface(void);
@
\fimcodigo

E isso termina a nossa descrição de todas as funções que suportaremos.

\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{interface.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{interface.h}:

\iniciocodigo
@(src/interface.h@>=
#ifndef __WEAVER_INTERFACE
#define __WEAVER_INTERFACE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
@<Declaração de Função (interface.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (interface.h)'', o mesmo nome apresentado no trecho de
código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{interface.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/interface.c@>=
#include "interface.h"

@<Variáveis Locais (interface.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}


\fim
