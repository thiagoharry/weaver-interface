\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface de Usuário Weaver}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of the user
  interface used by Weaver Game Engine. The code presented here are
  intended to be used when creating buttons, text, menus and other
  user interface elements. It basically manages shaders, create
  elements that can be moved, rotated, clicked and can react to mouse
  hovering. The API presented here are intended to be flexible, the
  user can extend it and change its behavious registering new
  functions.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo contém a implementação da interface de usuário do
  Moto de Jogos Weaver. O código apresentado aqui é projetado para ser
  usado ao criar botões, texto, menus e outros elementos de interface
  de usuário. O código deste artigo basicamente gerencia ``shaders''
  OpenGL e cria elementos que podem ser movidos, rotacionados,
  clicados e podem reagir quando o mouse passa sobre eles. A API
  apresentada aqui é projetada para ser flexível, o usuário pode
  ampliá-la e mudar seu comportamento registrando novas funções.}

\secao{1. Introdução}

Uma interface de usuário é como um programa se comunica com o usuário
e obtém informações dele. Em um programa típico temos menus, botões,
janelas de pop-up e outros elementos de interface típico. Mas em jogos
de cmputador a intrface de usuário tende a ser muito mais simples
conveitualmente, geralmente formada por alguns menus e por elementos
de visualização que dão informações sobre o estado do jogo. POr
exemplo, um número no canto da tela indicando quantas vidas o jogador
tem.

O fato é que no caso de um jogo de computador, não podemos assumir
nada sobre a aparência dos menus, sobre o que eles vã fazer e sobre o
que é cada elemento de interface. Um jogo de estratégia poderá ter
muuitos menus quando alguém clica com o mouse em uma unidade. Um jogo
de plataforma pode ter apenas informações sobre itens equipados e
número de vidas. A aparência de tais elementos pode variar enormemente
dependendo do estilo do jogo.

A única característica universal que iremos assumir para os elementos
de interface com o usuário é que eles sempre devem aparecer sobre o
cenário do jogo, não deve ser obscurecido por objetos que fazem parte
do mundo do jogo. Tipicamente renderizaremos as interfaces de usuário
depois de termos renderizado o mundo de nosso jogo. Além disso, eles
não irão interagir com elementos do mundo do jogo. Eles não fazem
parte diretamente do mundo que o jogo simula, eles são apenas
elementos que dão informações adicionais para o jogador sobre coisas
deste mundo, que de outra forma seriam difíceis de serem expressadas.

O nosso objetivo aqui será criar uma API onde o usuário pode criar uma
nova interface de usuário invocando a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>=
struct interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float width, float height);
@
\fimcodigo

Onde o primeiro argumento é o nome de um arquivo que será aberto e
interpretado descrevendo a textura da interface (pode ser um arquivo
com uma imagem, por exemplo) e o segundo argumento é um nome de
arquivo contendo o shader. Ambos os argumentos podem ser NULL. Um
shader nulo significa que um shader padrão será usado. Um arquivo
vazio significa que nenhuma textura será preenchida mas usaremos o
shader para desenhar a interface na tela. Os demais argumentos são a
posição e tamanho inicial da interface na tela.

Uma vez que tenhamos uma interface, poderemos movê-la com a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmove_interface(struct interface *i, float x, float y, float z);
@
\fimcodigo

Assumimos que a posição de uma interface é a coordenada em pixels de
seu centro. O eixo $x$ e $y$ representa a posição horizontal e
vertical. O eixo $z$ determina quais interfaces aparecerão na frente
se estiverem ocupando as mesmas posições no espaço.

Podemos também rotacioná-la com a função:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrotate_interface(struct interface *i, float rotation);
@
\fimcodigo

A função acima recebe o quanto a imagem será rotacionada em relação à
orientação padrão usando radianos como medida.

Podemos redimencionar a interface com a função abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wresize_interface(struct interface *i, float new_width, float new_height);
@
\fimcodigo

A função acima deverá respeitar limites ajustados pelo usuário, se
eles existirem. Pode-se estabelecer valores mínimos para uma interface
com o código abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_max_size_interface(struct interface *i, float max_width,
                              float max_height);
@
\fimcodigo

Um tamanho máximo de zero significa que a interface não tem um tamanho
máximo. Pode-se também ajustar um tamanho mínimo com a função abaixo:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_min_size_interface(struct interface *i, float min_width,
                              float min_height);
@
\fimcodigo

O tamanho mínimo e máximo de uma interface tem um papel mais
importante quando a nossa janela ou área de desenho é
redimencionada. Quando isso acontece, a função abaixo deve ser
chamada. Ela irá redimencionar e mover todas as interfaces para manter
a mesma proprção em relação à janela ou área de desenho. Mas ela fará
isso respeitando as restrições de tamanho máximo e mínimo estabelecida
pelas duas funções anteriores.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wupdate_size_interface(unsigned old_width, unsigned old_height,
                             unsigned new_width, unsigned new_height);
@
\fimcodigo

A função anterior redimenciona de maneira apropriada todas as
interfaces previamente criadas. Da mesma forma, a função abaixo
renderiza na tela todas as interfaces disponíveis, sem precisarmos
manualmente indicá-las:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrender_interface(void);
@
\fimcodigo

Mas renderizar todas as interfaces criadas pode não ser o desejado
pelo usuário. Pode ser que queiramos renderizar somente as últimas
interfaces criadas à partir de um ponto da história.  Para isso, a
função abaixo cria uma marcação no nosso histórico de criação de
interfaces. E toda vez que pedimos para renderizar, somente as
interfaces criadas depois da marcação serão rendrizadas:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmark_history_interface(void);
@
\fimcodigo

Mas e se queremos renderizar somente algumas das interfaces criadas
antes da marcação? Neste caso, podemos simplismente criar uma nova
interface que na verdade é uma ligação para uma anterior:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
struct interface *_Wlink_interface(struct interface *i);
@
\fimcodigo

Já para interagir com todas as interfaces criadas no passado até a
última marcação, usamos a função abaixo. Ela irá executar as ações
programadas quando um usuário passa o mouse sobre uma interface,
retira o mouse sobre uma interface ou clica nela:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool moving, bool left_click,
                          bool middle_click, bool right_click);
@
\fimcodigo


Mas como apagar iterfaces uma vez que não precisamos mais delas? Para
isso fornecemos a função abaixo que apaga todas as interfaces criadas
anteriormene até a última marcação na história. Ela também apaga a
última marcação existente, voltando o estado de nossa biblioteca até
como eraimediatamente antes de tal marcação ser criada. As interfaces
qu existirem antes de tal marcação, se existirem, serão novamente
renderizadas.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrestore_history_interface(void);
@
\fimcodigo

Tudo isso vai requerer que gerenciemos nosso histórico de interfaces,
suas marcações e seus shaders. E isso vai requerer que aloquemos e
desaloquemos memória. Há dois tipos de alocações que podemos fazer:
coisas permanentes que ficarão alocadas por possivelmente um bom tempo
e coisas temporárias que serão rapidamente desalocadas. Vamos então
armazenar a função de alocação e desalocação para estes dois casos:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@
\fimcodigo

Por padrão, usaremos simplesmente a função de alocação e desalocação
da biblioteca padrão. Mas o usuário pode personalizar cada uma destas
funções quando invoca a inicialização de nossa biblioteca:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
#include <stdlib.h> // Define tipo 'size_t'
void _Winit_interface(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *), ...);
@
\fimcodigo


É possível inicializar as funções de desalocação como
\monoespaco{NULL}. Isso significa que nós não iremos desalocar o que
foi alocado. Isso pode ser útil caso seu gerenciador de memória
gerencie de alguma forma a coleta de lixo e não quer ter interferência
no processo.

A função acima também aceita receber um número variável de argumentos
depois das quatro funções de alocação e desalocação. Esses argumentos
adicionais serão uma lista terminada em NULL de uma string seguida de
uma função geradora de interfaces. A string representa uma extensão
(por exemplo ``gif'', ``jpg'' ou outras) e a função que a sucede
recebe como argumento um nome de arquivo, as funções de alocação e
desalocação e um ponteiro para a interface que deve ser atualizada e
preenchida de acordo com o conteúdo do arquivo. Espera-se que a função
consiga abrir e interpretar o arquivo e gerar uma nova interface à
partir dele.  Desta forma, deixamos para o usuário a responsabilidade
de fornecer as funções que criam interfaces à partir de arquivos de
diferentes formatos.

Como apresentamos uma função de inicialização, vamos precisar também
da função de finalização:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wfinish_interface(void);
@
\fimcodigo

E isso termina a nossa descrição de todas as funções que suportaremos.

\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{interface.h}.

Podemos apresentar aqui a estrutura do arquivo
\monoespaco{interface.h}:

\iniciocodigo
@(src/interface.h@>=
#ifndef __WEAVER_INTERFACE
#define __WEAVER_INTERFACE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
@<Inclur Cabeçalhos Gerais (interface.h)@>
@<Macros Gerais (interface.h)@>
@<Declaração de Função (interface.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (interface.h)'', o mesmo nome apresentado no trecho de
código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{interface.c}
associado a este cabeçaho, o código será este:

\iniciocodigo
@(src/interface.c@>=
#include "interface.h"
@<Macros Locais (interface.c)@>
@<Estrutura de Dados Locais (interface.c)@>
@<Variáveis Locais (interface.c)@>
@
\fimcodigo

Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\subsecao{1.2. Suportando Múltiplas Threads}

A maior parte do código a ser definido neste documento é portável. O
único requisito assumido é que um contexto OpenGL está ativo e
funcionando. Contudo, há uma parte não-portável que deve ser definida
dependendo do sistema em que estamos: o suporte a mutex.

Um mutex é uma estrutura de dados abstrata usada para controlar acesso
de múltiplos processos a um recurso em comum. Eles serão tratados de
forma diferente dependendo do sistema operacional e ambiente. Devido à
seu caráter não-portável, eles serão introduzidos aqui, separados do
restante do código.

No Linux e BSD, o Mutex é definido pela biblioteca
\monoespaco{pthread} e segue a nomenclatura típica dela. No Windows um
Mutex é chamado de ``seção critica''. No Web Assembly não usaremos
Mutex, pois o cóigo não usará múltiplas threads.

\iniciocodigo
@<Macros Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#define _MUTEX_DECLARATION(mutex) pthread_mutex_t mutex
#elif defined(_WIN32)
#define _MUTEX_DECLARATION(mutex) CRITICAL_SECTION mutex
#elif defined(__EMSCRIPTEN__)
#define _MUTEX_DECLARATION(mutex)
#endif
@
\fimcodigo

Isso significa que no Linus e BSD nós precisamos inserir o cabeçalho
da biblioteca \monoespaco{pthread}. No Windows, basta inserir o
cabeçalho padrão do windows.

\iniciocodigo
@<Inclur Cabeçalhos Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#include <pthread.h>
#elif defined(_WIN32)
#include <windows.h>
#endif
@
\fimcodigo

No nosso código vamos precisar inicializar cada Mutex que
declararmos. Para isso, usaremos a seguinte macro:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_INIT(mutex) pthread_mutex_init(mutex, NULL);
#elif defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@
\fimcodigo

Para finalizar um Mutex quando não precisarmos mais, usamos a seguinte
macro:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(mutex);
#elif defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@
\fimcodigo

Tendo um Mutex, há duas operações que podemos fazer com ele. A
primeira é requerer o uso do Mutex. Neste momento, se algum outro
processo está usando ele, iremos esperar até que o Mutex esteja livre
novamente:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(mutex);
#elif defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@
\fimcodigo

E finalmente, depois de deixarmos de usar o recurso guardado pelo
Mutex, podemos liberar ele com o código abaixo:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(mutex);
#elif defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@
\fimcodigo

\secao{2. Estruturas de Dados}

Nesta seção descreveremos as três principais estruturas de dados que
gerenciaremos nesta API: as interfaces de usuário, as ligações para
interfaces já criadas e as marcações de tempo.

\subsecao{2.1. A Estrutura da Interface}

A principal estrutura deste documento será a estrutura que armazena
informações sobre a interface de usuário. A descrição dela é:

\iniciocodigo
@<Estrutura de Dados (interface.h)@>
struct interface {
  int type;
  void *next; // Ponteiro de lista encadeada
  float x, y, z;
  float rotation;
  GLfloat _transform_matrix[16];
  float height, width;
  floaf background_color[4], foreground_color[4];
  int integer;
  bool visible;
  GLuint _shader;
  _MUTEX_DECLARATION(interface_mutex);
  /* Atributos abaixo devem ser preenchidos por função de carregamento: */
  GLuint *_texture;
  bool _loaded_texture;
  bool animate;
  unsigned number_of_frames;
  unsigned current_frame;
  unsigned *frame_duration;
  unsigned long _t;
  int max_repetition;
};
\fimcodigo
@

Vamos agora descrever o que significa cada elemento desta estrutura.

O primeiro atributo é o tipo. Nós vamos querer armazenar as nossas
interfaces em uma lista encadeada (e por isso abaixo do tipo já temos
um ponteiro para montar a lista encadeada). Mas essa lista não
necessariamente armazenará interfaces como a acima. Nós podemos
armazenar na lista encadeada outras coisas, como marcações de tempo ou
então ligações para interfaces que já foram criadas antes. Nós
saberemos o quê exatamente tem em cada posição da lista encadeada
através do valor encontrado no tipo. O tipo pode então ser de três
tipos:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#define TYPE_INTERFACE 1 // Uma interface como a acima
#define TYPE_LINK      2 // Ligação para interface anterior
#define TYPE_MARKING   3 // Marcação no histórico de interfaces criadas
@
\fimcodigo

Toda vez então que o valor do primeiro atributo for 1, isso significa
que estamos diante de uma interface completa como a descrita acima.

Depois do tipo e so ponteiro, armazenamos as informações sobre posição
e tamanho da interface. Temos a sua posição em pixels (eixo $x$ e
$y$), seu ``índice-z'' (eixo $z$) que determina a ordem em que as
interfaces serão desenhadas e quais aparecerão na frente das outras, a
rotação (em radianos) da interface e a altura e largura (em
pixels). Todos estes valores podem ser lidos pelo usuário, mas não
devem ser modificados diretamente sem usar as funções adequadas para
isso e que srão definidas nas próximas seções. Isso porque para
corretamente mudar a posição, tamanho e rotação da interface,
precisamos atualizar a sua matriz de transfrmação (logo abaixo), que é
como o OpenG e nossos shaders realmente interpretam tais
informações. E com relação ao eixo $z$, se atualizamos ele, também
temos que atualizar uma outra lista a ser definida que controla a
ordem em que as interfaces são desenhadas na tela.

O atributo de cor de frente e de fundo representa cores no formato
RGBA onde cada valor individua é entre 0 e 1. Basicamente tais cores
serão sempre passadas para o shader de renderização. Mas não
necessariamente o shader irá usar tal informação.

Da mesma forma, o atributo inteiro que vem logo em seguida também é um
valor inteiro a ser passado para o shader. Não necessariamente ele
será usado, isso irá depender do shader.

O próximo atributo indica se a interface está visível ou não. Se não
estiver, ela não será renderizada.

O shader compilado a ser usado pela nossa interface aparece em
seguida.

E por fim, é inserida uma declaração de um mutex para que múltiplos
processos possam maniplar simultaneamente nossa interface.

Os atributos que vem à seguir desta parte inicialmente sempre começam
como sendo 0, falso ou nulo. É de responsabilidade da função de
carregamento preencher tais valores enquanto executa. A função de
carregamento é aquela que é responsável por ler um arquivo de
determinada extensão e gerar corretamente a textura da
interface.Funções de carregamento são informadas na inicialização
desta API.

Primeiro temos um ponteiro para a textura OpenGL que é passada para o
shader. Pode não ter somente uma textura, mas várias. Quando por
exemplo temos uma interface obtida através de um GIF animado, por
exemplo. Cada frame de animação será uma textura diferente.

Caso exista mais de uma textura, a próxima variável booleana determina
se a interface deve ser animada ou não. A variável pode ser modificada
à vontade durante a execução do programa para fazer com que a animação
pause ou continue.

Os dois próximos atributos representam o número total de frames da
animação (será sempre 1 quando não for uma interface animada) e qual o
frame atual em que estamos (o primeiro frame é o 0).

Em seguida encontramos um ponteiro que apontará para um vetor alocado
que conterá a duração de cada frame em unidades de tempo. Se a
interface possuir somente um ou nenhum frame, este ponteiro poderá
estar apontando para NULL.

A variável \monoespaco{\_t} será usada para realizar a contagem de
tempo internamente no caso de termos uma interface animada. Deve
iniciar como zero quando a interface é inicializada e sua textura
termina de ser carregada. Depois seguiremos incrementando o contador
automaticamente para assim sabermos quando o frame atual precisa ser
modificado ou não, a depender da duração de cada frame.

Por fim, o último atributo é, para o caso de termos uma interface
animada, quantas vezes devemos repetir até o final sua animação. O
valor de 0 significa que ela deverá ser repetida para sempre. Um valor
positivo coloca u limite no número de repetições. Quando repetirmos a
animação pela última vez permitida, ela ficará estacionada no último
frame sem voltar novamente para o primeiro.

\subsecao{2.2. Marcações no Histórico}

Como mencionado na Introdução, a lógica de quais interfaces estarão
acessíveis em um dado momento terá relação com as marcações feitas no
nosso histórico de interfaces. Todas as interfaces criadas após a
última marcação estão acessíveis, mas aquelas que forem mais antigas
que isso não poderão ser acessadas. Elas não serão renedeerizadas e
nem pode-se interagir com elas. Podem ser criadas várias marcações. E
a marcação mais recente existente pode ser destruída, o que destrói
as interfaces criadas depois dela.

Para que isso seja possível, cada marcação precisa memorizar qual era
a marcação anterior. Desta forma, quando apagamos uma marcação,
podemos substituir a marcação memorizada colocando-a no logar daquela
que foi removida. De fato, essa é a única coisa que precisamos
armazenar em uma marcação além dos dados típicos necessários para a
lista encadeada:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct marking {
  int type;
  void *next; // Ponteiro de lista encadeada
  struct marking *previous_marking;
};
@
\fimcodigo

Note que declaramos essa estrutura de dados internamente no arquivo
\monoespaco{interface.c}. Isso porque essa é uma estrutura que será
útil somente internamente à nossa API. Não haverá motivos para que o
usuário da API precise obter uma marcação destas. Ele irá interagir
com a existência delas somente por meio das funções
\monoespaco{\_Wmark\_history\_interface} e
\monoespaco{\_Wrestore\_history\_interface} descritas na Introdução.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}


\fim
