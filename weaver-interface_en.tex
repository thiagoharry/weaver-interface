\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of the user
  interface used by Weaver Game Engine. The code presented here are
  intended to be used when creating buttons, text, menus and other
  user interface elements. It basically manages shaders, create
  elements that can be moved, rotated, clicked and can react to mouse
  hovering. The API presented here are intended to be flexible, the
  user can extend it and change its behavious registering new
  functions.}

\secao{1. Introduction}

A graphical user interface is how a program communicates and takes
information from the user. Ina typical program we could have menus,
buttons, window pop-ups and other typical graphical elements. In games
the user intrface usually is conceptually simpler, made by some menus
and some viewing elements with information about the game state. For
example, a life counter in the corner of the screen.

The fact is that in a computer game we cannot assume almost nothing
about the appearence of the user interface. A strategy game could have
lots of menus appearing when the user click in some unit. A platform
game could have only information about equipped items and life
counter. The appearence and behaviour of such elements can change a
lot depending on the game style.

The sole universal characteristic that we will assume for our
interface elements is that they appear over the ame scenario, they are
not obscured by objects that are part of our game world. Typically we
will render the interfaces after rendering our game world. And
elements from the game world cannot interact with
interfaces. Interfaces are not part of the world that the game
simulates, they are just elements that give to the player information
that would be otherwise difficult to express.

Our objective here will be creating an AP where the user can create a
new interface using the function:

\iniciocodigo
@<Declaração de Função (interface.h)@>=
struct interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float width, float height);
@
\fimcodigo

Where the first argument is a file that will be open and interpreted
to get information about our interface texture (it could be an image
filename). The second argumetn is the file containing the OpenGL
shader. Both arguments can be NULL> A ull shader means that we will
use some default shader. A null file means that the interface will
have no texture. The other arguments are the initial position and size
for our interface.

We could define shaders more easily for them if we pass some
additional library with GLSL functions. This can be done passing to
this function a string with source code for function definitions in
GLSL:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_interface_shader_library(char *source);
@
\fimcodigo


When we have a interface, we can move it with the function:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmove_interface(struct interface *i, float x, float y, float z);
@
\fimcodigo

We assume that the position of an interface is the coordinate of its
center. The axis $x$ and $y$ represents the horizontal and vertical
position. The axis $z$ determines which interface will be in the front
if they occupy the same place in the space.

We can also rotate it with the function:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrotate_interface(struct interface *i, float rotation);
@
\fimcodigo

The function above gets as argument how much the interface will be
rotated in radians comparing with its notmal orientation.

We can also resize the interface with the function below:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wresize_interface(struct interface *i, float new_width, float new_height);
@
\fimcodigo

The function above will respect limits that can be adjusted by the
user, if they exist. We can set the minimum width and/or height for
some ineterface with the function below:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_max_size_interface(struct interface *i, float max_width,
                              float max_height);
@
\fimcodigo

The maximum size can be set to zero, which means that there will be no
maximum size. We can also set the minimum size:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_min_size_interface(struct interface *i, float min_width,
                              float min_height);
@
\fimcodigo

The maximum and minimum size of some interface have a more important
role when the window or drawing area is resized. When this happens,
the function below should be called. It will resize all interfaces to
keep the same proportion compared with the window or drawing area. But
this is limited by these minimum and maximum size limits set by the
two above functions.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wupdate_size_interface(unsigned old_width, unsigned old_height,
                             unsigned new_width, unsigned new_height);
@
\fimcodigo

The previous function acts over all previously created interfaces. In
the same way, the below function renders in the screen or drawing area
all the previously created interfaces without needing to list all
them:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrender_interface(void);
@
\fimcodigo

But rendering all previous interfaces may not be what the user wants,
Sometimes, a person want to render just the interfaces created after
some point of the history. For this, the function below creates a
marking in our interface history. After this, when we ask to render
all the interfaces, only the interfaces created after this marking
will be rendered:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmark_history_interface(void);
@
\fimcodigo

But what if we want to render some of the interfaces created before
the last history marking? In this case, we can create e a new
interface that in fact is just a link to a previously created
interface:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
struct interface *_Wlink_interface(struct interface *i);
@
\fimcodigo

To interact with all the previously created interfaces until the last
marking, we use the function below. It executes the programmed
actions, if they exist, for each interface if the user puts or removes
the mouse over them or if the user clicks in some interface:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool moving, bool left_click,
                          bool middle_click, bool right_click);
@
\fimcodigo


But how can we erase and destroy some interface when we do not need it
anymore? For this we use the following function that erases all
previously created interfaces after the last marking in the
history. This also erases the last marking, returning the state to
what it was just before the creation of that marking. The interfaces
before that marking will be rendered again.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrestore_history_interface(void);
@
\fimcodigo

All this requires that we manage our interface history, its shaders
and the markings.  And this requires memory allocation and
disallocation. There are two kinds of allocations that we could use:
for permanent things that will be kept in the memory for a long time
and for temporary things that will be disallocated soon. We will store
functions to allocate and disallocate in the two cases:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
#include <stdlib.h>
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@
\fimcodigo

By default we will use the allocation and disallocation functions from
the standard library. But the user can choose custom functions to
replace them. Besides these four functions, we will also use custom
functions imediatelly before and after loading a new interfac. These
functions will be initialized by NULL, but the user later can change
them to other functions:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static void *(*before_loading_interface)(void) = NULL;
static void *(*after_loading_interface)(void) = NULL;
@
\fimcodigo

The idea is that all custom functions are chosen during the API
initialization:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
#include <stdlib.h> // Define  'size_t' type
void _Winit_interface(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void *(*before_loading_interface)(void),
                      void *(*after_loading_interface)(void),
                      ...);
@
\fimcodigo

It is possible to initializa the disallocation functions with
\monoespaco{NULL}. This means that we will not disallocate what we
allocate. This could be useful in some scenarios where the memory
manager uses its own garbage collector and do not want interferences.

The function above accepts a variable number of arguments. What cames
after the six initial functions is a NULL-terminated list of arguments
composed by a string followed by some function that create a new
interface given a file. The string represents a filename extension
(for example, ``gif'', ``jpg'' or others) and the function after the
string should get as arguments a filename, the functions for
allocation and disallocation and a pointer to the interface that
should be filled with information from the file. It is expected that
each of these functions can interpret correctly the files with
extensions given previously and fill the given interface with textures
extracted from the file. This way, we pass to the user the
responsability of provinding functions able to create interfaces from
different file formats.

As we have an initialization function, we will need also a
finalization function:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wfinish_interface(void);
@
\fimcodigo

And this ends the description of our API.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{interface.h}.

We can show the structure of the file \monoespaco{interface.h}:

\iniciocodigo
@(src/interface.h@>=
#ifndef __WEAVER_INTERFACE
#define __WEAVER_INTERFACE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif  
@<Inclur Cabeçalhos Gerais (interface.h)@>
@<Macros Gerais (interface.h)@>
@<Declaração de Função (interface.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Declaração de Função
(interface.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{interface.c} file related
with this header, its structure is:

\iniciocodigo
@(src/interface.c@>=
#include "interface.h"
@<Cabeçalhos Locais (interface.c)@>
@<Macros Locais (interface.c)@>
@<Estrutura de Dados Locais (interface.c)@>
@<Variáveis Locais (interface.c)@>
@<Funções Auxiliares Locais (interface.c)@>
@<Definição de Funções da API (interface.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\subsecao{1.2. Supporting Multiple Threads}

Most code that will be defined in this document is portable. The only
assumed requeriment is that an OpenGL context was already created and
is active. However, there is a single non-portable part that we should
define differently depending on the system and environment: the mutex
support.

A mmutex is a data sctructure that controls the access for multiple
proccesses to a single common resource. They are treated differently
depending on the operating system and environment. Because of its
non-portability, we will introduce them here, separated from the
remaining of the code.

On Linux and BSD a Mutex is defined using the library
\monoespaco{pthread} and follows its naming convention. On Windows, a
Mutex is called a ``critical section''. On Web Assembly, for now, we
will not define them because we are not allowing multiple threads in
this environment.

\iniciocodigo
@<Macros Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#define _MUTEX_DECLARATION(mutex) pthread_mutex_t mutex
#elif defined(_WIN32)
#define _MUTEX_DECLARATION(mutex) CRITICAL_SECTION mutex
#elif defined(__EMSCRIPTEN__)
#define _MUTEX_DECLARATION(mutex)
#endif
@
\fimcodigo

This means that on Linux and BSD, we need to include headers for
\monoespaco{pthread} library. On Windows, we just include the default
Windows header:

\iniciocodigo
@<Inclur Cabeçalhos Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#include <pthread.h>
#elif defined(_WIN32)
#include <windows.h>
#endif
@
\fimcodigo

In our code we will need to initializa each declared Mutex. For this,
we will ise the following macros:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_INIT(mutex) pthread_mutex_init(mutex, NULL);
#elif defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@
\fimcodigo

To finalize and delete the Mutex, we use the following macros:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(mutex);
#elif defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@
\fimcodigo

Once we have a Mutex, there are two operations that we can do. The
first is ask for Mutex usage. If some other proccess is already using
it, this means that we wait until the Mutex is available:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(mutex);
#elif defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@
\fimcodigo

And finally, if we finished to use the resource guarded by the Mutex,
we signal that other proccesses can now use it:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(mutex);
#elif defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@
\fimcodigo

\secao{2. Data Structures}

In this section we will describe the three main data structures
managed by this API: the user interfaces, the links for previous user
interfaces and the marks in the history.

\subsecao{2.1. User Interface Data Structure}

The main and more complex data structure in this document is the data
structure that stores information about user interfaces. The full
definition for this data structure is:

\iniciocodigo
@<Estrutura de Dados (interface.h)@>
struct interface {
  int type;
  void *next; // Pointer for linked list
  float x, y, z;
  float rotation;
  float height, width;
  floaf background_color[4], foreground_color[4];
  int integer;
  bool visible;
  GLfloat _transform_matrix[16];
  GLuint _shader;
  _MUTEX_DECLARATION(interface_mutex);
  /* Attributes below should be filled by the loading function: */
  GLuint *_texture;
  bool _loaded_texture;
  bool animate;
  unsigned number_of_frames;
  unsigned current_frame;
  unsigned *frame_duration;
  unsigned long _t;
  int max_repetition;
};
\fimcodigo
@

Now we will describe what means each part of this structure.

The first attribute is the type. We will store our structure in a
linked list (and because of this the next attribute is a pointer that
will form the linked list). But in this list we want to store the
three different data structures. When we visit an element in the list,
how should we know if we are visiting an user interface, a link or a
mark in the history? We will differentiate between them by this type,
that will be a different value for each of these types:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#define TYPE_INTERFACE 1 // A user interface, like the one above
#define TYPE_LINK      2 // A linking to a previous user interface
#define TYPE_MARKING   3 // A marking in our history of user interface creation
@
\fimcodigo

After the type and the pointer, we store the position in pixels (for
axis $x$ and $y$) for our interface and its z-index (axis $z$). We
then store the rotation (in radians) and the width and height (in
pixels). All these values can be read, but should not be changed
directly. To change its valies, it is necessary to use the designed
functions that we will define in the future sections. This is
necessary becaus to correctly change the position, rotation and size,
we must update the transform matrix, which is how OpenGL and our
shaders really represent these informations. And the z-index must also
be updated in anoother list, where we will store the correct order to
render each element.

The foreground and background color are colors in RGBA format with
individual values in the range between 0 and 1. Such values will be
passed to the shader, but not necessarily it will use these
informations. Likewise, the integer attribute also is data that will
be sent to the shader, but the shader can choose to use or not the
information.

The next attribute is if the interface is visible or not. If not, it
will not be rendered in the screen.

Next we store the compiled shader for our interface and also declare
the mutex for the structure.

The attributes after this part are initialized with 0, false and
NULL. But while the loading function is interpreting the filename, it
should change and update the values. The loading function is one of
the functions that should be passed to the initialization function in
our API and that interpret files with a given extension to produce the
textures and other information for our interfaces.

In this part first we have a pointer for the OpenGL texture for our
interface. We can have not a single texture, but several
textures. This happens if we open a file that can store more than one
image. Or when we open an animated GIF, for example. Each frame in the
animation will be a different texture.

If we have more than one texture, the next variable determines if the
interface should animate or not. The value can be changed to pause or
resume the animation.

The two next attributes are the number of frames in our animation and
in which frame we are now. The first frame is number 0.

Next we have a pointer that should have allocated a vector with the
duration for each frame. If the number of frames is 1 or 0, thes can
point to NULL.

The variable \monoespaco{\_t} will count the time elapsed. It should be
set to zero after the interface is loaded and its texture is
ready. After this, we will increment the variable periodically and
this will help us to know when we should change the current frame in
an animated interface.

Finally, the next attribute represents in an animated interface how
many times we should repeat the animation. If the value is zero, then
we will repeat forever. If it is a positive value and we repeated the
animation the allowed number of times, then the interface will stop
the animation and stay in the last frame.

\subsecao{2.2. Markings in History}

As mentioned in the Introduction, the logic that determines which
interfaces are accessible in a given moment uses markings done in our
interface history. All interfaces created after the last marking
areaccessible and the ones created before the marking are not
accessible: they will not be rendered and the user cannot interact
with them. Several markings can be creted. And the most recent marking
that still exist can be destroyed, which also destroy the interfaces
created after it.

To make this pssible, each marking must store a pointer to the
previous marking.This way, when we erase a marking, we can replace the
deleted marking with the marking pointed by it. In fact, this is the
only information that we need to store in a marking besides data
related with the linked list:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct marking {
  int type;
  void *next; // Ponter to linked list
  struct marking *previous_marking;
};
@
\fimcodigo

Notice that we declared this as a local data structure in file
\monoespaco{interface.c}. We did this because this structure will be
useful only internally in our API. The user will not need to
manipulate directly markings. The user will interact with this data
structure indirectly, when using functions
\monoespaco{\_Wmark\_history\_interface} and
\monoespaco{\_Wrestore\_history\_interface} described in the
Introduction.

\subsecao{2.3. Link to Other Interfaces}

If some interface is inaccessible because is older than the last
marking in the history, it is possible to create a link to it usinf
function \monoespaco{\_Wlink\_interface}. The linking to the older
interface acts as a recently created interface and then the older
interface becames accessible again. Creating a link means create and
store in the linked list the following struct:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct link {
  int type;
  void *next; // Pointer to linked list
  struct interface *linked_interface;
};
@
\fimcodigo

Besides the information necessary to the linked list, like the type
and the pointer to the next element, the only information that we need
to store in a link is a pointer to the older linked interface.

\secao{3. Initializing and Finalizing the API}

The purpose of initialization in this API is choosing all the custom
functions that wil be used to allocate, disallocate, and to manage
interface creation. The finalization disallocates data necessary to
store information about some of these functions. It also reset all the
cusatom functions to default values.

\subsecao{3.1. Initialization}

Here our objecticve is set the six custom functions discussed in the
Introduction, and also get a list with variable size with all
functions that will be used to interpret the content of files with a
given extension.

To store the functions from the list with variable size, we need the
following structure:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct file_function {
  char *extension;
  void (*load_texture)(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void *(*before_loading_interface)(void),
                      void *(*after_loading_interface)(void),
                      char *source_filename, struct interface *target);
};
static unsigned number_of_file_functions_in_the_list = 0;
static struct file_function *list_of_file_functions = NULL;
@
\fimcodigo

The struct is basically a pair composed by a function that extracts
textures from a given file (and gets all the custom functions that
should be used) and by a file extension string. After defining the
structure, we create a pointer to a list of such structures. Initially
the pointer represents an empty list.

Now we can define the initialization function. What this function will
do os set the six basic custom functions, count how many additional
custom functions we have to interpret files, allocate the space
necessary in the list above (using the custom allocation functions)
and fill the newly allocated list:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>=
void _Winit_interface(void *(*new_permanent_alloc)(size_t),
                      void (*new_permanent_free)(void *),
                      void *(*new_temporary_alloc)(size_t),
                      void (*new_temporary_free)(void *),
                      void *(*new_before_loading_interface)(void),
                      void *(*new_after_loading_interface)(void), ...){
  if(new_permanent_alloc != NULL) /* Parte 1: Preencher as 6 Funções */
    permanent_alloc = new_permanent_alloc;
  if(new_temporary_alloc != NULL)
    temporary_alloc = new_temporary_alloc;
  permanent_free = new_permanent_free;
  temporary_free = new_temporary_free;
  before_loading_interface = new_before_loading_interface;
  after_loading_interface = new_after_loading_interface;
  {
    int count = -1, i; /* Parte 2: Contar quantas mais funções existem */
    va_list args;
    char *ext;
    void (*func)(void *(*permanent_alloc)(size_t),
                 void (*permanent_free)(void *), void *(*temporary_alloc)(size_t),
                 void (*temporary_free)(void *),
                 void *(*before_loading_interface)(void),
                 void *(*after_loading_interface)(void),
                 char *source_filename, struct interface *target);
    va_start(args, new_after_loading_interface);
    do{
      count ++;
      ext = va_arg(args, char *);
      func = va_arg(args, void (*)(void *(*)(size_t), void (*)(void *),
                                   void *(*)(size_t), void (*)(void *),
                                   void *(*)(void), void *(*)(void),
                                   char *, struct interface *)); 
    } while(ext != NULL);
    number_of_file_functions_in_the_list = count;
    list_of_file_functions = (struct file_function *)
                               permanent_alloc(sizeof(struct file_function) * 
                                               count); // Parte 3: Alocar o resto
    va_start(args, new_after_loading_interface);
    for(i = 0; i < count; i ++){
      list_of_file_functions[i].extension = va_arg(args, char *);
      list_of_file_functions[i].load_texture =
             va_arg(args, void (*)(void *(*)(size_t), void (*)(void *),
                                   void *(*)(size_t), void (*)(void *),
                                   void *(*)(void), void *(*)(void),
                                   char *, struct interface *));
    }
  }
}
@
\fimcodigo

The above function is very verbose because C is verbose when we have
functions with variable number of parameters and these parameters can
be pointers to functions with lots of parameters. Despite the
verbosity, the initialization above is very simple.

The use of some resources, like accessing arguments by
\monoespaco{va\_list} requires the following header:

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>=
#include <stdarg.h>
@
\fimcodigo

\subsecao{3.2. Finalization}

The function that complements our initialization is the finalization
function. If in the initialization we end allocating memory to store a
list of functions that interpret files, in finalizagion we begin
diallocating this memory. If in the initialization we begin setting
the six basic custom functions, in the finalization we end setting
these functions to the default initial values:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>+=
void _Wfinish_interface(void){
  @<Finalização da API de Interface@>
  permanent_free(list_of_file_functions);
  number_of_file_functions_in_the_list = 0;
  permanent_alloc = malloc;
  temporary_alloc = malloc;
  permanent_free = free;
  temporary_free = free;
  before_loading_interface = NULL;
  after_loading_interface = NULL;
}
@
\fimcodigo

Notice that we let additional space in red for additional code that we
will eventually need in the finalization when we increase the API
complexity defining new functions in the next sections.

And this undoes everything done in the initialization. It is possible
to initialize and finalize the API without problems.

\secao{4. Shaders}

One of the things that we need to define is our default shader to be
used if the user do not pass a custom shader when creating an
interface. Defining the custom shader gives us a great opportunity to
present the requisites for shaders supported by this API. We will
require a specific format for shaders.

First, all shader source files must specify in the first line the
version for the shading language used. We will use the GLSL language,
but this language have different versions. We will not require that
the user put this information in all shader sources, we will write
this automatically.

To choose the correct version for the GLSL language that will be used
in all the shaders, we will check the value in macro
\monoespaco{W\_GLSL\_VERSION}. This macro is what will be written in
the first line of each shader source code. The macro can be defined by
the user passing adequate compilation flags, or including the macro
definition in the code, but if this is not done, then we will use the
standard string ``\monoespaco{\#version 100\\n}''. This standard value
means that we will use the shading language OpenGL ES v1.00. We eill
define the macro, if it does not exist, in the beginning of the file
that defines our functions:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if !defined(W_GLSL_VERSION)
#define W_GLSL_VERSION "#version 100\n"
#endif
@
\fimcodigo

There is at least two different shaders that we need to define for
each interface. The first is the vertex shader, that will be processed
for each vertex in our interface. The other is the fragment shader,
that will process each individual pixel. Each of them have a different
source code. But as we defined in the Introduction, when we specify a
shader to each interface passing a single filename with its source
code. We do not pass two fileames. How can we represent two source
codes in the same file?

Well, as the GLSL language support C-like macros, we can do this in
the same way that we can create a program in C that will run in both
Windows and Linux. We use conditional macros to include conditionally
custom source code for each environment. For this, we must have two
different GLSL macros. One that will be defined when we need a vertex
shader and the other when we need a fragment shader:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static char vertex_shader_macro[] = "#define VERTER_SHADER\n";
static char fragment_shader_macro[] = "#define FRAGMENT_SHADER\n";
@
\fimcodigo

In the shader source code, we just need to check which macro is
defined and we can include code conditionally depending on this.

The next thing that we must define is how to support libraries in our
GLSL code. They can make shader definition easier. The user can
define additional GLSL functions that will be available in all
interface shaders storing its source code in the following variable:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static char *shader_library = "";
@
\fimcodigo

The variable will be changed by the function seen in the Introduction
to increment GLSL with new functions. Such function is extremely
simple, it justs assign a string with function source code to the
variable above:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>+=
void _Wset_interface_shader_library(char *source){
  shader_library = source;
}
@
\fimcodigo

But we should not forget that when finalizing our API, we need to undo
the assignment. Otherwise, when a user finalize and initialize again
the API, the second initialization would get the same function
definitions assigned in the first initialization:

\iniciocodigo
@<Finalização da API de Interface@>=
shader_library = "";
@
\fimcodigo

Now we will see how to compile a shader given these informations and a
string with its source code. First we will include the OpenGL
headers. By default we will use OpenGL ES 2.0. But in some
environments, like in Windows, where this OpenGL version not
necessarily is present, we can use the default OpenGL header, provided
that it supports shaders. But it is possible that the user will need
to include additional headers on Windows passing additional flags
during the compilation. We will also include the standard input/output
library to print in the screen error messages if there are errors in
the shader source code.

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>+=
#if defined(__linux__) || defined(BSD)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#endif
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
#include <stdio.h>
@
\fimcodigo

Once we have the necessary headers, we can define the function that
given a shader source code, compiles it to a complete shader
program. Compiling a shader means creating on OpenGL the two kind of
shaders (vertex and fragment), compile both and link them in a
single program.

\iniciocodigo
@<Funções Auxiliares Locais (interface.c)@>=
@<Funções para Checar Erros de Compilação@>
static GLuint new_shader(const char *source_code){
  GLuint vertex_shader, fragment_shader, program;
  const char *list_of_source_code[4];
  vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
  list_of_source_code[0] = W_GLSL_VERSION;
  list_of_source_code[1] = vertex_shader_macro;
  list_of_source_code[2] = shader_library;
  list_of_source_code[3] = source_code;
  glShaderSource(vertex_shader, 4, list_of_source_code, NULL);
  list_of_source_code[1] = fragment_shader_macro;
  glShaderSource(fragment_shader, 4, list_of_source_code, NULL);
  glCompileShader(vertex_shader);
  if(check_compiling_error(vertex_shader))
    return 0;
  glCompileShader(fragment_shader);
  if(check_compiling_error(fragment_shader))
    return 0;
  program = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);
  if(check_linking_error(program))
    return 0;
  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);
  return program;
}
@
\fimcodigo

What we are not showing above is hoe we verify if the shader was
compiled and linked successfully. To do this with shader compilation,
we use the function below. It checks if a compiling error happened and
if so, it reads in the logs what was wrong and print in the
screen. Notice that here we are using the temporary allocation and
deallocation functions to manage space in the memory for the error
message. The function also returns if an error was found or not.

\iniciocodigo
@<Funções para Checar Erros de Compilação@>=
static bool check_compiling_error(GLuint shader){
  GLint status;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    int info_log_length;
    char *error_msg;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetShaderInfoLog(shader, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
  return false;
}
@
\fimcodigo

Checking if some error happened during the linking stag is
similar. However, after the linking we can make even better. We can
try to validate the shader simulating its usage to detect additional
errors that could not be detected in syntatic analysis. Howerer, this
is an expensive operation, we will do this only if the macro
\monoespaco{W\_DEBUG\_INTERFACE} is defined. In this case, we assume
that we are in debug mode.

\iniciocodigo
@<Funções para Checar Erros de Compilação@>+=
static bool check_linking_error(GLuint program){
  GLint status;
  GLsizei info_log_length;
  char *error_msg;
  glGetProgramiv(program, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#if defined(W_DEBUG_INTERFACE)
  glValidateProgram(program);
  glGetProgramiv(program, GL_VALIDATE_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_message = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#endif
  return false;  
}
@
\fimcodigo

And this ends the description of how we compile a new shader and print
messages in case of errors in the source code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}



\fim
