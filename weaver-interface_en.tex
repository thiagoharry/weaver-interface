\input tex/epsf.tex
\font\sixteen=cmbx16
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}
\def\iniciocodigo{\lineskip=0pt\parskip=0pt}
\def\fimcodigo{\twelve\parskip=0pt plus 1pt\lineskip=1pt}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Weaver User Interface}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article contains the implementation of the user
  interface used by Weaver Game Engine. The code presented here are
  intended to be used when creating buttons, text, menus and other
  user interface elements. It basically manages shaders, create
  elements that can be moved, rotated, clicked and can react to mouse
  hovering. The API presented here are intended to be flexible, the
  user can extend it and change its behavious registering new
  functions.}

\secao{1. Introduction}

A graphical user interface is how a program communicates and takes
information from the user. Ina typical program we could have menus,
buttons, window pop-ups and other typical graphical elements. In games
the user intrface usually is conceptually simpler, made by some menus
and some viewing elements with information about the game state. For
example, a life counter in the corner of the screen.

The fact is that in a computer game we cannot assume almost nothing
about the appearence of the user interface. A strategy game could have
lots of menus appearing when the user click in some unit. A platform
game could have only information about equipped items and life
counter. The appearence and behaviour of such elements can change a
lot depending on the game style.

The sole universal characteristic that we will assume for our
interface elements is that they appear over the ame scenario, they are
not obscured by objects that are part of our game world. Typically we
will render the interfaces after rendering our game world. And
elements from the game world cannot interact with
interfaces. Interfaces are not part of the world that the game
simulates, they are just elements that give to the player information
that would be otherwise difficult to express.

Our objective here will be creating an AP where the user can create a
new interface using the function:

\iniciocodigo
@<Declaração de Função (interface.h)@>=
struct interface *_Wnew_interface(char *filename, char *shader_filename,
                                  float x, float y, float z, float width,
                                  float height);
@
\fimcodigo

Where the first argument is a file that will be open and interpreted
to get information about our interface texture (it could be an image
filename). The second argument is the file containing the OpenGL
shader. Both arguments can be NULL> A null shader means that we will
use some default shader. A null file means that the interface will
have no texture. The other arguments are the initial position and size
for our interface.

We could define shaders more easily for them if we pass some
additional library with GLSL functions. This can be done passing to
this function a string with source code for function definitions in
GLSL:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_interface_shader_library(char *source);
@
\fimcodigo


When we have a interface, we can move it with the function:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmove_interface(struct interface *i, float x, float y, float z);
@
\fimcodigo

We assume that the position of an interface is the coordinate of its
center. The axis $x$ and $y$ represents the horizontal and vertical
position. The axis $z$ determines which interface will be in the front
if they occupy the same place in the space.

We can also rotate it with the function:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrotate_interface(struct interface *i, float rotation);
@
\fimcodigo

The function above gets as argument how much the interface will be
rotated in radians comparing with its notmal orientation.

We can also resize the interface with the function below:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wresize_interface(struct interface *i, float new_width, float new_height);
@
\fimcodigo

The function above will respect limits that can be adjusted by the
user, if they exist. We can set the minimum width and/or height for
some ineterface with the function below:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_max_size_interface(struct interface *i, float max_width,
                              float max_height);
@
\fimcodigo

The maximum size can be set to zero, which means that there will be no
maximum size. We can also set the minimum size:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wset_min_size_interface(struct interface *i, float min_width,
                              float min_height);
@
\fimcodigo

The maximum and minimum size of some interface have a more important
role when the window or drawing area is resized. When this happens,
the function below should be called. It will resize all interfaces to
keep the same proportion compared with the window or drawing area. But
this is limited by these minimum and maximum size limits set by the
two above functions.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wupdate_size_interface(unsigned old_width, unsigned old_height,
                             unsigned new_width, unsigned new_height);
@
\fimcodigo

The previous function acts over all previously created interfaces. In
the same way, the below function renders in the screen or drawing area
all the previously created interfaces without needing to list all
them:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrender_interface(void);
@
\fimcodigo

But rendering all previous interfaces may not be what the user wants,
Sometimes, a person want to render just the interfaces created after
some point of the history. For this, the function below creates a
marking in our interface history. After this, when we ask to render
all the interfaces, only the interfaces created after this marking
will be rendered:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wmark_history_interface(void);
@
\fimcodigo

But what if we want to render some of the interfaces created before
the last history marking? In this case, we can create e a new
interface that in fact is just a link to a previously created
interface:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
struct interface *_Wlink_interface(struct interface *i);
@
\fimcodigo

To interact with all the previously created interfaces until the last
marking, we use the function below. It executes the programmed
actions, if they exist, for each interface if the user puts or removes
the mouse over them or if the user clicks in some interface:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Winteract_interface(int mouse_x, int mouse_y, bool moving, bool left_click,
                          bool middle_click, bool right_click);
@
\fimcodigo


But how can we erase and destroy some interface when we do not need it
anymore? For this we use the following function that erases all
previously created interfaces after the last marking in the
history. This also erases the last marking, returning the state to
what it was just before the creation of that marking. The interfaces
before that marking will be rendered again.

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wrestore_history_interface(void);
@
\fimcodigo

All this requires that we manage our interface history, its shaders
and the markings.  And this requires memory allocation and
disallocation. There are two kinds of allocations that we could use:
for permanent things that will be kept in the memory for a long time
and for temporary things that will be disallocated soon. We will store
functions to allocate and disallocate in the two cases:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
#include <stdlib.h>
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@
\fimcodigo

By default we will use the allocation and disallocation functions from
the standard library. But the user can choose custom functions to
replace them. Besides these four functions, we will also use custom
functions imediatelly before and after loading a new interfac. These
functions will be initialized by NULL, but the user later can change
them to other functions:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static void *(*before_loading_interface)(void) = NULL;
static void *(*after_loading_interface)(void) = NULL;
@
\fimcodigo

The idea is that all custom functions are chosen during the API
initialization:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
#include <stdlib.h> // Define  'size_t' type
void _Winit_interface(int *window_width, int *window_height,
                      void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void *(*before_loading_interface)(void),
                      void *(*after_loading_interface)(void),
                      ...);
@
\fimcodigo

It is possible to initializa the disallocation functions with
\monoespaco{NULL}. This means that we will not disallocate what we
allocate. This could be useful in some scenarios where the memory
manager uses its own garbage collector and do not want interferences.

The function above accepts a variable number of arguments. First it
gets pointers to where we store our window width and height. They will
be stored here:

\iniciocodigo
@<Variáveis Locais (interface.c)@>=
static int *window_width = NULL, *window_height = NULL;
@
\fimcodigo

The window size is followed by custom functions as described before.
What cames after the six initial functions is a NULL-terminated list
of arguments composed by a string followed by some function that
create a new interface given a file. The string represents a filename
extension (for example, ``gif'', ``jpg'' or others) and the function
after the string should get as arguments a filename, the functions for
allocation and disallocation and a pointer to the interface that
should be filled with information from the file. It is expected that
each of these functions can interpret correctly the files with
extensions given previously and fill the given interface with textures
extracted from the file. This way, we pass to the user the
responsability of provinding functions able to create interfaces from
different file formats.

As we have an initialization function, we will need also a
finalization function:

\iniciocodigo
@<Declaração de Função (interface.h)@>+=
void _Wfinish_interface(void);
@
\fimcodigo

And this ends the description of our API.

\subsecao{1.1. Literate Programming}

Our API will be written using the literate programming technique,
proposed by Knuth on [Knuth, 1984]. It consist in writting a computer
program explaining didactically in a text what is being done while
presenting the code. The program is compiled extracting the computer
code directly from the didactical text. The code shall be presented in
a way and order such that it is best for explaining for a human. Not
how it would be easier to compile.

Using this technique, this document is not a simple documentation for
our code. It is the code by itself. The part that will be extracted to
be compiled can be identified by a gray background. We begin each
piece of code by a title that names it. For example, immediately
before this subsection we presented a series of function
declarations. And how one could deduct by the title, most of them will
be positioned in the file \monoespaco{interface.h}.

We can show the structure of the file \monoespaco{interface.h}:

\iniciocodigo
@(src/interface.h@>=
#ifndef __WEAVER_INTERFACE
#define __WEAVER_INTERFACE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define  'bool' type
#if !defined(_WIN32)
#include <sys/param.h> // Needed on BSD, but does not exist on Windows
#endif  
@<Inclui Cabeçalhos Gerais (interface.h)@>
@<Macros Gerais (interface.h)@>
@<Estrutura de Dados (interface.h)@>
@<Declaração de Função (interface.h)@>
#ifdef __cplusplus
}
#endif
#endif
@
\fimcodigo

The cde above shows the default boureaucracy to define a header for
our C API. The two first lines and the last one are macros that ensure
that this header will not be inserted more than once in a single
compiling unit. The lines 3, 4, 5 and the three lines before the last
one make the header adequate to be used in C++ code. This tells the
compiler that we are using C code and that therefore, the compiler is
free to use optimizations assuming that we will not use C++ exclusive
techniques, like operator overloading. Next we include a header that
will let us to use boolean variables. And there are some parts in
red. Note that one of them is called ``Declaração de Função
(interface.h)'', the same title used in most of the code declared
previously. This means that all the previous code with this title will
be inserted in that position inside this file. The other parts in red
represent code that we will define in the next sections.

If you want to know how is the \monoespaco{interface.c} file related
with this header, its structure is:

\iniciocodigo
@(src/interface.c@>=
#include "interface.h"
@<Cabeçalhos Locais (interface.c)@>
@<Macros Locais (interface.c)@>
@<Estrutura de Dados Locais (interface.c)@>
@<Variáveis Locais (interface.c)@>
@<Funções Auxiliares Locais (interface.c)@>
@<Definição de Funções da API (interface.c)@>
@
\fimcodigo

All the code presented in this document will be placed in one of these
two files. Besides them, no other file will be created.

\subsecao{1.2. Supporting Multiple Threads}

Most code that will be defined in this document is portable. The only
assumed requeriment is that an OpenGL context was already created and
is active. However, there is a single non-portable part that we should
define differently depending on the system and environment: the mutex
support.

A mmutex is a data sctructure that controls the access for multiple
proccesses to a single common resource. They are treated differently
depending on the operating system and environment. Because of its
non-portability, we will introduce them here, separated from the
remaining of the code.

On Linux and BSD a Mutex is defined using the library
\monoespaco{pthread} and follows its naming convention. On Windows, a
Mutex is called a ``critical section''. On Web Assembly, for now, we
will not define them because we are not allowing multiple threads in
this environment.

\iniciocodigo
@<Macros Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#define _MUTEX_DECLARATION(mutex) pthread_mutex_t mutex
#elif defined(_WIN32)
#define _MUTEX_DECLARATION(mutex) CRITICAL_SECTION mutex
#elif defined(__EMSCRIPTEN__)
#define _MUTEX_DECLARATION(mutex)
#endif
@
\fimcodigo

This means that on Linux and BSD, we need to include headers for
\monoespaco{pthread} library. On Windows, we just include the default
Windows header:

\iniciocodigo
@<Inclui Cabeçalhos Gerais (interface.h)@>=
#if defined(__linux__) || defined(BSD)
#include <pthread.h>
#elif defined(_WIN32)
#include <windows.h>
#endif
@
\fimcodigo

In our code we will need to initializa each declared Mutex. For this,
we will ise the following macros:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_INIT(mutex) pthread_mutex_init(mutex, NULL);
#elif defined(_WIN32)
#define MUTEX_INIT(mutex) InitializeCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_INIT(mutex)
#endif
@
\fimcodigo

To finalize and delete the Mutex, we use the following macros:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_DESTROY(mutex) pthread_mutex_destroy(mutex);
#elif defined(_WIN32)
#define MUTEX_DESTROY(mutex) DeleteCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_DESTROY(mutex)
#endif
@
\fimcodigo

Once we have a Mutex, there are two operations that we can do. The
first is ask for Mutex usage. If some other proccess is already using
it, this means that we wait until the Mutex is available:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_WAIT(mutex) pthread_mutex_lock(mutex);
#elif defined(_WIN32)
#define MUTEX_WAIT(mutex) EnterCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_WAIT(mutex)
#endif
@
\fimcodigo

And finally, if we finished to use the resource guarded by the Mutex,
we signal that other proccesses can now use it:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if defined(__linux__) || defined(BSD)
#define MUTEX_SIGNAL(mutex) pthread_mutex_unlock(mutex);
#elif defined(_WIN32)
#define MUTEX_SIGNAL(mutex) LeaveCriticalSection(mutex);
#elif defined(__EMSCRIPTEN__)
#define MUTEX_SIGNAL(mutex)
#endif
@
\fimcodigo

\secao{2. Data Structures}

In this section we will describe the three main data structures
managed by this API: the user interfaces, the links for previous user
interfaces and the marks in the history.

\subsecao{2.1. User Interface Data Structure}

The main and more complex data structure in this document is the data
structure that stores information about user interfaces. The full
definition for this data structure is:

\iniciocodigo
@<Estrutura de Dados (interface.h)@>=
struct interface {
  int type;
  void *next; // Pointer for linked list
  float x, y, z;
  float rotation;
  float height, width;
  float background_color[4], foreground_color[4];
  int integer;
  bool visible;
  GLfloat _transform_matrix[16];
  GLuint _shader;
  _MUTEX_DECLARATION(interface_mutex);
  /* Attributes below should be filled by the loading function: */
  GLuint *_texture;
  bool _loaded_texture;
  bool animate;
  unsigned number_of_frames;
  unsigned current_frame;
  unsigned *frame_duration;
  unsigned long _t;
  int max_repetition;
};
@
\fimcodigo


As we are using OpenGL data types, like \monoespaco{GLuint}, we should
include the OpenGL headers:

\iniciocodigo
@<Inclui Cabeçalhos Gerais (interface.h)@>+=
#if defined(__linux__) || defined(BSD)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#endif
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
@
\fimcodigo


Now we will describe what means each part of this structure.

The first attribute is the type. We will store our structure in a
linked list (and because of this the next attribute is a pointer that
will form the linked list). But in this list we want to store the
three different data structures. When we visit an element in the list,
how should we know if we are visiting an user interface, a link or a
mark in the history? We will differentiate between them by this type,
that will be a different value for each of these types:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#define TYPE_INTERFACE 1 // A user interface, like the one above
#define TYPE_LINK      2 // A linking to a previous user interface
#define TYPE_MARKING   3 // A marking in our history of user interface creation
@
\fimcodigo

After the type and the pointer, we store the position in pixels (for
axis $x$ and $y$) for our interface and its z-index (axis $z$). We
then store the rotation (in radians) and the width and height (in
pixels). All these values can be read, but should not be changed
directly. To change its valies, it is necessary to use the designed
functions that we will define in the future sections. This is
necessary becaus to correctly change the position, rotation and size,
we must update the transform matrix, which is how OpenGL and our
shaders really represent these informations. And the z-index must also
be updated in anoother list, where we will store the correct order to
render each element.

The foreground and background color are colors in RGBA format with
individual values in the range between 0 and 1. Such values will be
passed to the shader, but not necessarily it will use these
informations. Likewise, the integer attribute also is data that will
be sent to the shader, but the shader can choose to use or not the
information.

The next attribute is if the interface is visible or not. If not, it
will not be rendered in the screen.

Next we store the compiled shader for our interface and also declare
the mutex for the structure.

The attributes after this part are initialized with 0, false and
NULL. But while the loading function is interpreting the filename, it
should change and update the values. The loading function is one of
the functions that should be passed to the initialization function in
our API and that interpret files with a given extension to produce the
textures and other information for our interfaces.

In this part first we have a pointer for the OpenGL texture for our
interface. We can have not a single texture, but several
textures. This happens if we open a file that can store more than one
image. Or when we open an animated GIF, for example. Each frame in the
animation will be a different texture.

If we have more than one texture, the next variable determines if the
interface should animate or not. The value can be changed to pause or
resume the animation.

The two next attributes are the number of frames in our animation and
in which frame we are now. The first frame is number 0.

Next we have a pointer that should have allocated a vector with the
duration for each frame. If the number of frames is 1 or 0, thes can
point to NULL.

The variable \monoespaco{\_t} will count the time elapsed. It should be
set to zero after the interface is loaded and its texture is
ready. After this, we will increment the variable periodically and
this will help us to know when we should change the current frame in
an animated interface.

Finally, the next attribute represents in an animated interface how
many times we should repeat the animation. If the value is zero, then
we will repeat forever. If it is a positive value and we repeated the
animation the allowed number of times, then the interface will stop
the animation and stay in the last frame.

\subsecao{2.2. Markings in History}

As mentioned in the Introduction, the logic that determines which
interfaces are accessible in a given moment uses markings done in our
interface history. All interfaces created after the last marking
areaccessible and the ones created before the marking are not
accessible: they will not be rendered and the user cannot interact
with them. Several markings can be creted. And the most recent marking
that still exist can be destroyed, which also destroy the interfaces
created after it.

To make this pssible, each marking must store a pointer to the
previous marking.This way, when we erase a marking, we can replace the
deleted marking with the marking pointed by it. In fact, this is the
only information that we need to store in a marking besides data
related with the linked list:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct marking {
  int type;
  void *next; // Ponter to linked list
  struct marking *previous_marking;
};
@
\fimcodigo

Notice that we declared this as a local data structure in file
\monoespaco{interface.c}. We did this because this structure will be
useful only internally in our API. The user will not need to
manipulate directly markings. The user will interact with this data
structure indirectly, when using functions
\monoespaco{\_Wmark\_history\_interface} and
\monoespaco{\_Wrestore\_history\_interface} described in the
Introduction.

\subsecao{2.3. Link to Other Interfaces}

If some interface is inaccessible because is older than the last
marking in the history, it is possible to create a link to it usinf
function \monoespaco{\_Wlink\_interface}. The linking to the older
interface acts as a recently created interface and then the older
interface becames accessible again. Creating a link means create and
store in the linked list the following struct:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct link {
  int type;
  void *next; // Pointer to linked list
  struct interface *linked_interface;
};
@
\fimcodigo

Besides the information necessary to the linked list, like the type
and the pointer to the next element, the only information that we need
to store in a link is a pointer to the older linked interface.

\secao{3. Initializing and Finalizing the API}

The purpose of initialization in this API is choosing all the custom
functions that wil be used to allocate, disallocate, and to manage
interface creation. The finalization disallocates data necessary to
store information about some of these functions. It also reset all the
cusatom functions to default values.

\subsecao{3.1. Initialization}

Here our objecticve is set the six custom functions discussed in the
Introduction, and also get a list with variable size with all
functions that will be used to interpret the content of files with a
given extension.

To store the functions from the list with variable size, we need the
following structure:

\iniciocodigo
@<Estrutura de Dados Locais (interface.c)@>=
struct file_function {
  char *extension;
  void (*load_texture)(void *(*permanent_alloc)(size_t),
                      void (*permanent_free)(void *),
                      void *(*temporary_alloc)(size_t),
                      void (*temporary_free)(void *),
                      void *(*before_loading_interface)(void),
                      void *(*after_loading_interface)(void),
                      char *source_filename, struct interface *target);
};
static unsigned number_of_file_functions_in_the_list = 0;
static struct file_function *list_of_file_functions = NULL;
@
\fimcodigo

The struct is basically a pair composed by a function that extracts
textures from a given file (and gets all the custom functions that
should be used) and by a file extension string. After defining the
structure, we create a pointer to a list of such structures. Initially
the pointer represents an empty list.

Now we can define the initialization function. What this function will
do os set the six basic custom functions, count how many additional
custom functions we have to interpret files, allocate the space
necessary in the list above (using the custom allocation functions)
and fill the newly allocated list:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>=
void _Winit_interface(int *window_width_p, int *window_height_p,
                      void *(*new_permanent_alloc)(size_t),
                      void (*new_permanent_free)(void *),
                      void *(*new_temporary_alloc)(size_t),
                      void (*new_temporary_free)(void *),
                      void *(*new_before_loading_interface)(void),
                      void *(*new_after_loading_interface)(void), ...){
  if(new_permanent_alloc != NULL) /* Part 1: Get the 6 functions + window size */
    permanent_alloc = new_permanent_alloc;
  if(new_temporary_alloc != NULL)
    temporary_alloc = new_temporary_alloc;
  permanent_free = new_permanent_free;
  temporary_free = new_temporary_free;
  before_loading_interface = new_before_loading_interface;
  after_loading_interface = new_after_loading_interface;
  window_width = window_width_p;
  window_height = window_height_p;
  {
    int count = -1, i; /* Part 2: Count the remaining functions */
    va_list args;
    char *ext;
    void (*func)(void *(*permanent_alloc)(size_t),
                 void (*permanent_free)(void *), void *(*temporary_alloc)(size_t),
                 void (*temporary_free)(void *),
                 void *(*before_loading_interface)(void),
                 void *(*after_loading_interface)(void),
                 char *source_filename, struct interface *target);
    va_start(args, new_after_loading_interface);
    do{
      count ++;
      ext = va_arg(args, char *);
      func = va_arg(args, void (*)(void *(*)(size_t), void (*)(void *),
                                   void *(*)(size_t), void (*)(void *),
                                   void *(*)(void), void *(*)(void),
                                   char *, struct interface *)); 
    } while(ext != NULL);
    number_of_file_functions_in_the_list = count;
    list_of_file_functions = (struct file_function *)
                               permanent_alloc(sizeof(struct file_function) * 
                                               count); // Part 3: Allocate them
    va_start(args, new_after_loading_interface);
    for(i = 0; i < count; i ++){
      list_of_file_functions[i].extension = va_arg(args, char *);
      list_of_file_functions[i].load_texture =
             va_arg(args, void (*)(void *(*)(size_t), void (*)(void *),
                                   void *(*)(size_t), void (*)(void *),
                                   void *(*)(void), void *(*)(void),
                                   char *, struct interface *));
    }
  }
  @<Inicialização da API de Interface@>
}
@
\fimcodigo

The above function is very verbose because C is verbose when we have
functions with variable number of parameters and these parameters can
be pointers to functions with lots of parameters. Despite the
verbosity, the initialization above is very simple.

In the end, in red, we marked a place where we will put additional
initialization code that we will define in the next sections.

The use of some resources, like accessing arguments by
\monoespaco{va\_list} requires the following header:

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>=
#include <stdarg.h>
@
\fimcodigo

\subsecao{3.2. Finalization}

The function that complements our initialization is the finalization
function. If in the initialization we end allocating memory to store a
list of functions that interpret files, in finalizagion we begin
diallocating this memory. If in the initialization we begin setting
the six basic custom functions, in the finalization we end setting
these functions to the default initial values:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>+=
void _Wfinish_interface(void){
  @<Finalização da API de Interface@>
  permanent_free(list_of_file_functions);
  number_of_file_functions_in_the_list = 0;
  permanent_alloc = malloc;
  temporary_alloc = malloc;
  permanent_free = free;
  temporary_free = free;
  before_loading_interface = NULL;
  after_loading_interface = NULL;
}
@
\fimcodigo

Notice that we let additional space in red for additional code that we
will eventually need in the finalization when we increase the API
complexity defining new functions in the next sections.

And this undoes everything done in the initialization. It is possible
to initialize and finalize the API without problems.

\secao{4. Shaders}

One of the things that we need to define is our default shader to be
used if the user do not pass a custom shader when creating an
interface. Defining the custom shader gives us a great opportunity to
present the requisites for shaders supported by this API. We will
require a specific format for shaders.

First, all shader source files must specify in the first line the
version for the shading language used. We will use the GLSL language,
but this language have different versions. We will not require that
the user put this information in all shader sources, we will write
this automatically.

To choose the correct version for the GLSL language that will be used
in all the shaders, we will check the value in macro
\monoespaco{W\_GLSL\_VERSION}. This macro is what will be written in
the first line of each shader source code. The macro can be defined by
the user passing adequate compilation flags, or including the macro
definition in the code, but if this is not done, then we will use the
standard string ``\monoespaco{\#version 100\\n}''. This standard value
means that we will use the shading language OpenGL ES v1.00. We eill
define the macro, if it does not exist, in the beginning of the file
that defines our functions:

\iniciocodigo
@<Macros Locais (interface.c)@>=
#if !defined(W_GLSL_VERSION)
#define W_GLSL_VERSION "#version 100\n"
#endif
@
\fimcodigo

There is at least two different shaders that we need to define for
each interface. The first is the vertex shader, that will be processed
for each vertex in our interface. The other is the fragment shader,
that will process each individual pixel. Each of them have a different
source code. But as we defined in the Introduction, when we specify a
shader to each interface passing a single filename with its source
code. We do not pass two fileames. How can we represent two source
codes in the same file?

Well, as the GLSL language support C-like macros, we can do this in
the same way that we can create a program in C that will run in both
Windows and Linux. We use conditional macros to include conditionally
custom source code for each environment. For this, we must have two
different GLSL macros. One that will be defined when we need a vertex
shader and the other when we need a fragment shader:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static const char vertex_shader_macro[] = "#define VERTEX_SHADER\n";
static const char fragment_shader_macro[] = "#define FRAGMENT_SHADER\n";
@
\fimcodigo

In the shader source code, we just need to check which macro is
defined and we can include code conditionally depending on this.

Next we need to specify the default precision for each variable type
if the user do not specify one in variable declaration. This is done
using the keyword \monoespaco{precision} followed by the precision
qualifier (\monoespaco{lowp}, \monoespaco{mediump},
\monoespaco{highp}) and by a variable type. Here we will define as
default the highest possible precision. For less important variables,
the user always can lower the precision trying to make the shader more
efficient.

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static const char precision_qualifier[] = "precision highp float;\n"
                                          "precision highp int;\n";
@
\fimcodigo

The next thing that we must define is how to support libraries in our
GLSL code. They can make shader definition easier. The user can
define additional GLSL functions that will be available in all
interface shaders storing its source code in the following variable:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static char *shader_library = "";
@
\fimcodigo

The variable will be changed by the function seen in the Introduction
to increment GLSL with new functions. Such function is extremely
simple, it justs assign a string with function source code to the
variable above:

\iniciocodigo
@<Definição de Funções da API (interface.c)@>+=
void _Wset_interface_shader_library(char *source){
  shader_library = source;
}
@
\fimcodigo

But we should not forget that when finalizing our API, we need to undo
the assignment. Otherwise, when a user finalize and initialize again
the API, the second initialization would get the same function
definitions assigned in the first initialization:

\iniciocodigo
@<Finalização da API de Interface@>=
shader_library = "";
@
\fimcodigo

Now we will see how to compile a shader given these informations and a
string with its source code. First we will include the standard
input/output library to print in the screen error messages if there
are errors in the shader source code. The OpenGL headers are already
included in \monoespaco{interface.h}.

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>+=
#if defined(__linux__) || defined(BSD)
#include <EGL/egl.h>
#include <GLES2/gl2.h>
#endif
#if defined(_WIN32)
#pragma comment(lib, "Opengl32.lib")
#include <windows.h>
#include <GL/gl.h>
#endif
#include <stdio.h>
@
\fimcodigo

Once we have the necessary headers, we can define the function that
given a shader source code, compiles it to a complete shader
program. Compiling a shader means creating on OpenGL the two kind of
shaders (vertex and fragment), compile both and link them in a
single program.

\iniciocodigo
@<Funções Auxiliares Locais (interface.c)@>=
@<Funções para Checar Erros de Compilação@>
static GLuint new_shader(const char *source_code){
  GLuint vertex_shader, fragment_shader, program;
  const char *list_of_source_code[5];
  vertex_shader = glCreateShader(GL_VERTEX_SHADER);
  fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
  list_of_source_code[0] = W_GLSL_VERSION;
  list_of_source_code[1] = vertex_shader_macro;
  list_of_source_code[2] = precision_qualifier;
  list_of_source_code[3] = shader_library;
  list_of_source_code[4] = source_code;
  glShaderSource(vertex_shader, 5, list_of_source_code, NULL);
  list_of_source_code[1] = fragment_shader_macro;
  glShaderSource(fragment_shader, 5, list_of_source_code, NULL);
  glCompileShader(vertex_shader);
  if(check_compiling_error(vertex_shader))
    return 0;
  glCompileShader(fragment_shader);
  if(check_compiling_error(fragment_shader))
    return 0;
  program = glCreateProgram();
  glAttachShader(program, vertex_shader);
  glAttachShader(program, fragment_shader);
  glLinkProgram(program);
  if(check_linking_error(program))
    return 0;
  glDeleteShader(vertex_shader);
  glDeleteShader(fragment_shader);
  return program;
}
@
\fimcodigo

What we are not showing above is hoe we verify if the shader was
compiled and linked successfully. To do this with shader compilation,
we use the function below. It checks if a compiling error happened and
if so, it reads in the logs what was wrong and print in the
screen. Notice that here we are using the temporary allocation and
deallocation functions to manage space in the memory for the error
message. The function also returns if an error was found or not.

\iniciocodigo
@<Funções para Checar Erros de Compilação@>=
static bool check_compiling_error(GLuint shader){
  GLint status;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &status);
  if(status == GL_FALSE){
    int info_log_length;
    char *error_msg;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetShaderInfoLog(shader, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
  return false;
}
@
\fimcodigo

Checking if some error happened during the linking stag is
similar. However, after the linking we can make even better. We can
try to validate the shader simulating its usage to detect additional
errors that could not be detected in syntatic analysis. Howerer, this
is an expensive operation, we will do this only if the macro
\monoespaco{W\_DEBUG\_INTERFACE} is defined. In this case, we assume
that we are in debug mode.

\iniciocodigo
@<Funções para Checar Erros de Compilação@>+=
static bool check_linking_error(GLuint program){
  GLint status;
  GLsizei info_log_length;
  char *error_msg;
  glGetProgramiv(program, GL_LINK_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#if defined(W_DEBUG_INTERFACE)
  glValidateProgram(program);
  glGetProgramiv(program, GL_VALIDATE_STATUS, &status);
  if(status == GL_FALSE){
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_log_length);
    error_msg = (char *) temporary_alloc(info_log_length);
    glGetProgramInfoLog(program, info_log_length, &info_log_length, error_msg);
    fprintf(stderr, "Shader Error: %s\n", error_msg);
    if(temporary_free != NULL)
      temporary_free(error_msg);
    return true;
  }
#endif
  return false;  
}
@
\fimcodigo

And this ends the description of how we compile a new shader and print
messages in case of errors in the source code.

Now we can define the default shader source code that will be used if
the user do not use a custom shader. The shader objective will be
showing the texture associated with the interface.

The source code for the default shader will be stored in the following
constant:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static const char default_shader_source[] = ""
@<Atributos, Uniformes e Variantes de Shader@>
"#if defined(VERTEX_SHADER)\n"
@<Shader de Vértice Padrão@>
"#else\n"
@<Shader de Fragmento Padrão@>
"#endif\n"
                                           "";
@
\fimcodigo

The source code will be composed by string literals stored in the
constant variable above. In the case of the vertex shader, it will
multiply each vertex by the model-view matrix that stores information
about its size, position and rotation. It will also set which texture
coordinate is associated with each vertex.

To understand the code, you need to consider that all interfaces will
have the same vertices: $(0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1,
0)$. They are declared below:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static const float interface_vertices[12] = {0.0, 0.0, 0.0,
  1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0 };
@
\fimcodigo

All interfaces will begin as a square positioned in the corner of the
screen and it will occupy possibly all the screeen, or most of it. To
transform this fix square in different sizes, positions and rotations,
we will use different model-view matrices. Each interface will have
its own model-view matrix.

\iniciocodigo
@<Shader de Vértice Padrão@>=
"void main(){\n"
"  gl_Position = model_view_matrix * vec4(vertex_position, 1.0);\n"
"  texture_coordinate = vec2(vertex_position.x, vertex_position.y);\n"
"}\n"
@
\fimcodigo


In the fragment shader, for each pixel we will draw the color
associated with the texture in a given position:

\iniciocodigo
@<Shader de Fragmento Padrão@>=
"void main(){\n"
"  vec4 texture = texture2D(texture1, texture_coordinate);\n"
"  gl_FragData[0] = texture;\n"
"}\n"
@
\fimcodigo

Now we need to define in the shaders its attributes, uniforms and
varyings. The attributes are read-only data specified for each vertex.
The sole attribute that we will define is the vertex position, in
coordinates $(x, y, z)$. The coordinates $x$ and $y$ will be between 0
and 1 and $z=0$, as described previously. Attributes are declared only
in vertex shaders.

\iniciocodigo
@<Atributos, Uniformes e Variantes de Shader@>=
"#if defined(VERTEX_SHADER)\n"
"attribute vec3 vertex_position;\n"
"#endif\n"
@
\fimcodigo

Uniforms are variables that also will be passed to vertices, but they
will not change between them. Therefore, the fragment shader do not
need to interpolate its value. We will store as uniforms the
foreground color, the background color, the model-view matrix, the
object size in pixels, the current time in seconds, the integer
associated with each interface and its texture:

\iniciocodigo
@<Atributos, Uniformes e Variantes de Shader@>+=
"uniform vec4 foreground_color, background_color;\n"
"uniform mat4 model_view_matrix;\n"
"uniform vec2 interface_size;\n"
"uniform float time;\n"
"uniform int integer;\n"
"uniform sampler2D texture1;\n"
@
\fimcodigo

Finally, varyings are variables that can be changed by the vertex
shader and will be given to the fragment vertice, that interpolates
using values from neighbor vertices. It is as a varying that we
declare the texture coordinate:

\iniciocodigo
@<Atributos, Uniformes e Variantes de Shader@>+=
"varying mediump vec2 texture_coordinate;\n"
@
\fimcodigo

We will compile thes default shader during the initialization and
store it after compiled in the following variable:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static GLuint default_shader_program;
@
\fimcodigo

We compile the default shader here:

\iniciocodigo
@<Inicialização da API de Interface@>=
default_shader_program = new_shader(default_shader_source);
@
\fimcodigo

And in the finalization we destroy this default program:

\iniciocodigo
@<Finalização da API de Interface@>+=
glDeleteProgram(default_shader_program);
@
\fimcodigo

Notice that we did not use all the variables defined in the default
shader. The unused variables will be discarded during the compilation
as an optimization. But we declared them anyway just to list the
supported variables that can be used by custom shaders defined by the
user.

By the way, talking about custom shaders, they will be sent by the
user using the function \monoespaco{\_Wnew\_interface} and will be
specified as a path to a file where the source code is. For this case,
we will define a function that creates a new shader program from a
filename given as argument:

\iniciocodigo
@<Funções Auxiliares Locais (interface.c)@>=
static GLuint new_shader_from_file(const char *filename){
  char *buffer;
  size_t source_size;
  FILE *fp;
  GLuint shader_program;
  fp = fopen(filename, "r");
  if(fp == NULL)  return 0;
  // Vai pro fim do arquivo para ler o tamanho e volta pro começo:
  fseek(fp, 0, SEEK_END);
  source_size = ftell(fp);
  rewind(fp);
  // Aloca e lê buffer
  buffer = (char *) temporary_alloc(sizeof(char) * (source_size + 1));
  if(buffer == NULL) return 0;
  fread(buffer, sizeof(char), source_size, fp);
  buffer[source_size] = '\0';
  shader_program = new_shader(buffer);
  if(temporary_free != NULL) temporary_free(buffer);
  return shader_program;
}
@
\fimcodigo


The last problem that we will solve in this section is what should we
render as default texture when the user supplies no texture for a
given interface. For these cases, We will create a texture composed by
a single white pixel:

\iniciocodigo
@<Variáveis Locais (interface.c)@>+=
static GLuint default_texture;
@
\fimcodigo

We will create this texture during the initialization. This is done in
the following code, where we generate the texture in OpenGL, associate
it as the current 2D-texture and specify the white pixel explaining
how it is represented. In the end, the last two lines of code below
sets how the texture pixels should be interpolated. This is a global
configuration for all the next textures. We ask to use a linear
interpolation, what gives us a basic anti-aliasing. If needed, the
user can later change this default configuration.

\iniciocodigo
@<Inicialização da API de Interface@>+=
{
  GLubyte pixels[3] = {255, 255, 255};
  glGenTextures(1, &default_texture);
  glBindTexture(GL_TEXTURE_2D, default_texture);
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE,
               pixels);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
}
@
\fimcodigo

And in the finalization we discard the created texture:

\iniciocodigo
@<Finalização da API de Interface@>+=
glDeleteTextures(1, &default_texture);
@
\fimcodigo

\secao{5. The Model-View Matrix}

As we have seen, all interfaces will be represented by four vertices
whose edges have the fixed size ``1''. What will make each interface
have its own size, position and rotation is the model-view matrix that
we will use for each interface.

To understand the matrix, first recall that when we use it in our
default vertex shader, whose code was already shown, we convert each
vertex to a point in 4 dimensions, instead of 3 or 2. The piece of
code \monoespaco{vec4{vertex\_position, 1.0)}} basically take the
coordinate in three dimensions and add a fourth dimension whose value
always will be 1.

We will do it because only in 4 dimensions it is possible to represent
all the geometric operations of rotation, translation and scaling as
matrix multiplications. Which means that only with 4 dimensions all
them are linear operations. Video cards are very fast when computing
matrix multiplication, treating these geometric operations in other
ways that are not matrix multiplication would create a negative impact
in the performance.

Before seeing the final form of the model-view matrix, we will first
see each of its different parts isolated. First assume that we have a
four-dimensional vector $(x_0, y_0, z_0, 1)$ multiplying our
matrix. If we are interested only in translating the vector to other
position, we could multiply the translation matrix below by our
vector:

$$ \left[{{1 \atop 0}\atop {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{x \atop y}\atop{0\atop
      1}}\right]\left[{{x_0\atop y_0}\atop {z_0\atop
      1}}\right]=\left[{{1x_0+0y_0+0z_0+x\atop 0x_0+1y_0+0z_0+y}\atop
    {0x_0+0y_0+1z_0+0\atop
      0x_0+0y_0+0z_0+1}}\right]=\left[{{x_0+x\atop y_0+y}\atop
    {z_0\atop 1}}\right]
$$


To change the size of some interface, both the width and the height,
assuming that the interface is centered in the origin $(0, 0, 0, 1)$,
we can multiply each vector for the following scaling matrix:

$$ \left[{{w \atop 0}\atop {0\atop 0}}{{0 \atop h}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]\left[{{x_0\atop y_0}\atop {z_0\atop
      1}}\right]=\left[{{wx_0+0y_0+0z_0+0\atop 0x_0+hy_0+0z_0+0}\atop
    {0x_0+0y_0+1z_0+0\atop 0x_0+0y_0+0z_0+1}}\right]=\left[{{wx_0\atop
      hy_0}\atop {z_0\atop 1}}\right]
$$

And finally, to rotate our interfaca $\theta$ radians, we could use
the following matrix that would produce the right result based on the
trigonometric formula for rotation:

$$ \left[{{cos(\theta) \atop \sin(\theta)}\atop {0\atop
      0}}{{-sin(\theta) \atop cos(\theta)}\atop {0 \atop 0}}{{0\atop
      0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop
      1}}\right]\left[{{x_0\atop y_0}\atop {z_0\atop
      1}}\right]=\left[{{x_0 cos(\theta)-y_0 sin(\theta)+0z_0+0\atop
      x_0 sin(\theta)+y_0 cos(\theta)+0z_0+0}\atop
    {0x_0+0y_0+1z_0+0\atop 0x_0+0y_0+0z_0+1}}\right]=\left[{{x_0
      cos(theta) - y_0 sin(\theta) \atop x_0 sin(\theta) + y_0
      cos(\theta)}\atop {z_0\atop 1}}\right]
$$

To form our model-view matrix, we will multiply all these matrices
depending of the values that we want for the scale, rotation and
translation. However, the order in which we multiply these matrices
change the result. The correct order for each operation is:

1. First we should center the interface square in the origin $(0, 0,
0, 1)$. (Matrix A)

2. Then we increase or decrease the size of each side of our
interface. (Matrix B).

3. We rotate the interface $\theta$ radians. (Matrix C)

4. Finally, we translate the interface for its correct position. (Matrix D)

To make these operations in the correct order, each vetor $v$ should
be multiplied in the following order:

$$
D(C(B(A v))) = (((DC)B)A)v
$$

If we use other order, things can go wrong. For example, instead of
rotating the interface using its center as the axis, we would use
its lower left corner or some other position as axis.

Instead of always having to multiply four matrices, we will compute
the format of the final matrix obtained when we multiply them. This
final matrix will be our model-view matrix. For example, multiplying
matrices $D$ and $C$, we get:

$$ DC=\left[{{1 \atop 0}\atop {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{x \atop y}\atop{0\atop
      1}}\right]\left[{{cos(\theta) \atop \sin(\theta)}\atop {0\atop
      0}}{{-sin(\theta) \atop cos(\theta)}\atop {0 \atop 0}}{{0\atop
      0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop 1}}\right]=
\left[{{cos(\theta) \atop sin(\theta)}\atop {0\atop 0}}
  {{-sin(\theta) \atop cos(\theta)}\atop {0 \atop 0}}
  {{0\atop 0}\atop{1 \atop 0}}
  {{x \atop y}\atop{0\atop 1}}\right]
$$

Now if we multiply the result by matrix $B$, we obtain:

$$ DCB = \left[{{cos(\theta) \atop sin(\theta)}\atop {0\atop 0}}
  {{-sin(\theta) \atop cos(\theta)}\atop {0 \atop 0}} {{0\atop
      0}\atop{1 \atop 0}} {{x \atop y}\atop{0\atop 1}}\right]\left[{{w
      \atop 0}\atop {0\atop 0}}{{0 \atop h}\atop {0 \atop 0}}{{0\atop
      0}\atop{1 \atop 0}}{{0 \atop 0}\atop{0\atop 1}}\right]=
\left[{{w\cdot cos(\theta) \atop w\cdot sin(\theta)}\atop {0\atop 0}}
  {{-h\cdot sin(\theta) \atop h\cdot cos(\theta)}\atop {0 \atop 0}}
  {{0\atop 0}\atop{1 \atop 0}}
  {{a \atop b}\atop{0\atop 1}}\right]
$$


And finally, we multiply this by matrix $A$, which center the
interface in $(0, 0, 0, 1)$. Recall that the interface originally is
centered in position $(1/2, 1/2, 0, 1)$. Therefore, matrix $A$ is just
a translation matrix with constant values:

$$
DCBA=\left[{{w\cdot cos(\theta) \atop w\cdot sin(\theta)}\atop {0\atop 0}}
  {{-h\cdot sin(\theta) \atop h\cdot cos(\theta)}\atop {0 \atop 0}}
  {{0\atop 0}\atop{1 \atop 0}}
  {{x \atop y}\atop{0\atop 1}}\right]
\left[{{1 \atop 0}\atop {0\atop 0}}{{0 \atop 1}\atop {0 \atop
      0}}{{0\atop 0}\atop{1 \atop 0}}{{-1/2 \atop -1/2}\atop{0\atop
      1}}\right]=
\left[{{w\cdot cos(\theta) \atop w\cdot sin(\theta)}\atop {0\atop 0}}
  {{-h\cdot sin(\theta) \atop h\cdot cos(\theta)}\atop {0 \atop 0}}
  {{0\atop 0}\atop{1 \atop 0}}
  {{-w/2\cdot cos(\theta) + h/2\cdot sin(\theta)+x \atop -w/2\cdot sin(\theta)-h/2\cdot cos(\theta)+y}\atop{0\atop 1}}\right]
$$

The format above is the final form of our model-view matrix for each
interface. Assuing that we have some given interface with correct
values in its variables \monoespaco{x},
\monoespaco{y}, \monoespaco{width}, \monoespaco{height} and
\monoespaco{rotation}, we can use these values to build its  model-view
matrix as shown in the auxiliary function below:

\iniciocodigo
@<Funções Auxiliares Locais (interface.c)@>=
static void set_model_view_matrix(struct interface *in){
  GLfloat width = ((GLfloat) in -> width) / ((GLfloat) *window_width);
  GLfloat height = ((GLfloat) in -> height) / ((GLfloat) *window_height);
  GLfloat x = ((GLfloat) in -> x) / ((GLfloat) *window_width);
  GLfloat y = ((GLfloat) in -> y) / ((GLfloat) *window_height);
  GLfloat cos_theta = cos(in -> rotation);
  GLfloat sin_theta = sin(in -> rotation);
  /* Primeira Coluna */
  in -> _transform_matrix[0] = width * cos_theta;
  in -> _transform_matrix[1] = width * sin_theta;
  in -> _transform_matrix[2] = 0.0;
  in -> _transform_matrix[3] = 0.0;
  /* Segunda Coluna */
  in -> _transform_matrix[4] = -height * sin_theta;
  in -> _transform_matrix[5] = height * cos_theta;
  in -> _transform_matrix[6] = 0.0;
  in -> _transform_matrix[7] = 0.0;
  /* Terceira Coluna */
  in -> _transform_matrix[8] = 0.0;
  in -> _transform_matrix[9] = 0.0;
  in -> _transform_matrix[10] = 1.0;
  in -> _transform_matrix[11] = 0.0;
  /* Quarta Coluna */
  in -> _transform_matrix[12] = -width/2 * cos_theta + height/2 * sin_theta + x;
  in -> _transform_matrix[13] = -width/2 * sin_theta - height/2 * cos_theta + y;
  in -> _transform_matrix[14] = 0.0;
  in -> _transform_matrix[15] = 1.0;
}
@
\fimcodigo

Using sine and cosine functions requires the header for mathematical
operations:

\iniciocodigo
@<Cabeçalhos Locais (interface.c)@>+=
#include <math.h>
@
\fimcodigo


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{References}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Issue 2, Pages 97--111.}



\fim
